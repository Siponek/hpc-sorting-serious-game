\chapter{Background and Literature Review}
\label{ch:background}

This chapter provides the foundational knowledge and contextual background necessary to understand the HPC Sorting Serious Game. We review key concepts in parallel computing, serious games in education, web-based game development, and multiplayer networking architectures.

%-----------------------------------------------------------------------
\section{Parallel Computing Fundamentals}
\label{sec:parallel-computing}

Parallel computing is the simultaneous execution of multiple computational tasks to solve problems more efficiently than sequential processing. As Moore's Law approaches its physical limits, parallel computing has become essential for improving computational performance across scientific computing, data analytics, and real-time systems.

%-----------------------------------------------------------------------
\subsection{Parallel Programming Paradigms}
\label{subsec:parallel-paradigms}

Two primary paradigms dominate parallel computing education and practice: shared-memory parallelism and distributed-memory parallelism.

\subsubsection{Shared-Memory Parallelism}

In shared-memory systems, multiple processors or cores access a common address space. All threads can read and write to the same memory locations, enabling efficient data sharing but requiring careful synchronization to prevent race conditions.

\textbf{Characteristics:}
\begin{itemize}
    \item All processors access the same physical memory
    \item Communication occurs through shared variables
    \item Synchronization primitives (locks, barriers, atomic operations) prevent conflicts
    \item Lower communication overhead compared to distributed memory
    \item Limited scalability due to memory bandwidth constraints
\end{itemize}

\textbf{Applications:} Shared-memory parallelism is ideal for problems requiring frequent communication between processing units, such as iterative algorithms, graph processing, and data analytics on multicore processors.

\subsubsection{Distributed-Memory Parallelism}

In distributed-memory systems, each processor has its own local memory. Processors communicate by explicitly sending and receiving messages over a network, requiring programmers to manage data distribution and communication patterns.

\textbf{Characteristics:}
\begin{itemize}
    \item Each processor has private memory space
    \item Communication requires explicit message passing
    \item Scalable to thousands or millions of processors
    \item Higher communication overhead and latency
    \item No shared state eliminates race conditions but complicates programming
\end{itemize}

\textbf{Applications:} Distributed-memory parallelism is essential for large-scale scientific simulations, weather modeling, molecular dynamics, and big data processing across cluster and supercomputer architectures.

%-----------------------------------------------------------------------
\subsection{OpenMP: Shared-Memory Programming}
\label{subsec:openmp}

OpenMP (Open Multi-Processing) is a widely-used API for shared-memory parallel programming in C, C++, and Fortran. It uses compiler directives (pragmas) to specify parallel regions, enabling incremental parallelization of sequential code.

\textbf{Core Concepts:}
\begin{description}
    \item[Parallel Regions] Code sections executed by multiple threads simultaneously
    \item[Work-Sharing Constructs] Distribute loop iterations or tasks among threads
    \item[Data Scoping] Variables can be shared (visible to all threads) or private (thread-local copies)
    \item[Synchronization] Barriers, critical sections, and atomic operations coordinate thread execution
    \item[Scheduling] Strategies (static, dynamic, guided) control how iterations are assigned to threads
\end{description}

\paragraph*{Example Code:}

\begin{lstlisting}[language=C++, caption={Simple OpenMP parallel loop}]
#pragma omp parallel for schedule(dynamic)
for (int i = 0; i < N; i++) {
    array[i] = compute_value(i);
}
\end{lstlisting}

\textbf{Educational Value:} OpenMP's simplicity makes it excellent for teaching parallel programming concepts. The incremental approach—starting with sequential code and adding pragmas—allows students to observe immediate performance improvements while learning about thread management, data dependencies, and race conditions.

%-----------------------------------------------------------------------
\subsection{MPI: Distributed-Memory Programming}
\label{subsec:mpi}

\begin{mdframed}[backgroundcolor=yellow!10, linecolor=orange, linewidth=2pt]
    \textbf{Note:} This section provides background on MPI for completeness and context within the broader HPC landscape. \textbf{The game implemented in this thesis focuses exclusively on OpenMP shared-memory parallelism.} MPI distributed-memory concepts are discussed here for educational context but are \textbf{not implemented} in the current version. See Chapter~\ref{ch:conclusion} for discussion of MPI as potential future work.
\end{mdframed}

MPI (Message Passing Interface) is the de facto standard for distributed-memory parallel programming. It provides a rich set of communication primitives for sending and receiving messages between processes, enabling scalable parallel computing on clusters and supercomputers.

\textbf{Core Operations:}
\begin{description}
    \item[Point-to-Point Communication] \texttt{MPI\_Send} and \texttt{MPI\_Recv} exchange messages between specific processes
    \item[Collective Communication] Operations like \texttt{MPI\_Bcast}, \texttt{MPI\_Gather}, and \texttt{MPI\_Reduce} involve all processes in a communicator
    \item[Process Groups] Communicators organize processes and define communication contexts
    \item[Data Types] MPI supports both primitive and user-defined data types for message content
\end{description}

\paragraph*{Example Code:}

\begin{lstlisting}[language=C++, caption={Simple MPI message passing}]
MPI_Init(&argc, &argv);
int rank, size;
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
MPI_Comm_size(MPI_COMM_WORLD, &size);

if (rank == 0) {
    // Master process
    MPI_Send(data, count, MPI_INT, 1, 0, MPI_COMM_WORLD);
} else if (rank == 1) {
    // Worker process
    MPI_Recv(data, count, MPI_INT, 0, 0, MPI_COMM_WORLD, &status);
}

MPI_Finalize();
\end{lstlisting}

\textbf{Educational Value:} MPI teaches students about distributed computing challenges including data distribution, explicit communication, latency management, and scalability. The message-passing model forces programmers to think carefully about data ownership and communication patterns, skills essential for modern distributed systems.

%-----------------------------------------------------------------------
\subsection{Parallel Sorting Algorithms}
\label{subsec:parallel-sorting}

Sorting is a fundamental algorithmic problem that benefits significantly from parallelization. Several parallel sorting strategies exist, each with different communication and synchronization requirements.

\paragraph*{Parallel Merge Sort:}
\begin{itemize}
    \item Recursively divide array into subarrays
    \item Sort subarrays in parallel
    \item Merge sorted subarrays (potentially in parallel)
    \item Well-suited for shared-memory systems
    \item Time complexity: $O(\frac{n \log n}{p})$ with $p$ processors
\end{itemize}

\paragraph*{Sample Sort (MPI Pattern):}
\begin{itemize}
    \item Distribute data across processes
    \item Each process sorts local data
    \item Select sample elements to determine global pivots
    \item Redistribute data based on pivots
    \item Each process sorts its final partition
    \item Commonly used in distributed-memory systems
    \item \textit{Note: Not implemented in this thesis; discussed for context}
\end{itemize}

\textbf{Relevance to Educational Game:} The card-sorting game mechanics map to parallel sorting algorithms. In the implemented game, players act as threads (OpenMP) coordinating through shared memory to sort cards efficiently, making abstract algorithmic concepts tangible through gameplay. Future extensions could explore MPI-style distributed sorting (see Chapter~\ref{ch:conclusion}).

%-----------------------------------------------------------------------
\section{Serious Games in Education}
\label{sec:serious-games}

Serious games—games designed primarily for purposes beyond entertainment—have emerged as powerful educational tools. This section reviews the theoretical foundations and empirical evidence supporting game-based learning.

%-----------------------------------------------------------------------
\subsection{Definition and Characteristics}
\label{subsec:serious-games-definition}

\citet{zyda2005visual} defines serious games as games that ``do not have entertainment, enjoyment, or fun as their primary purpose.'' These games leverage game design principles to achieve learning objectives, skill development, or behavioral change.

\textbf{Key Characteristics:}
\begin{itemize}
    \item \textbf{Clear Learning Objectives}: Explicit educational goals aligned with curricula
    \item \textbf{Engaging Mechanics}: Game elements (challenges, rewards, feedback) maintain motivation
    \item \textbf{Active Learning}: Players learn by doing, not passive observation
    \item \textbf{Immediate Feedback}: Instant consequences of actions reinforce learning
    \item \textbf{Safe Experimentation}: Risk-free environment for trial and error
    \item \textbf{Progressive Difficulty}: Challenges scale with player skill development
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Theoretical Foundations}
\label{subsec:game-based-learning-theory}

Game-based learning draws on several established educational theories:

\subsubsection{Constructivism}

Constructivist theory posits that learners actively construct knowledge through experience rather than passively receiving information. Games naturally support constructivist learning by placing players in problem-solving scenarios where they discover principles through experimentation.

\subsubsection{Flow Theory}

\citet{csikszentmihalyi1990flow} describes ``flow'' as the optimal psychological state where challenge level matches skill level, producing deep engagement. Well-designed educational games maintain flow by dynamically adjusting difficulty, keeping learners in the zone of proximal development.

\subsubsection{Experiential Learning}

Kolb's experiential learning cycle—concrete experience, reflective observation, abstract conceptualization, active experimentation—aligns perfectly with game mechanics. Players experience situations, observe outcomes, form hypotheses, and test them iteratively.

%-----------------------------------------------------------------------
\subsection{Empirical Evidence}
\label{subsec:serious-games-evidence}

Research consistently demonstrates the effectiveness of serious games for learning:

\paragraph*{\citet{connolly2012systematic} Meta-Analysis:}

A systematic literature review of 129 papers found that serious games positively impact learning outcomes across multiple domains. Key findings include:

\begin{itemize}
    \item Improved knowledge acquisition and retention
    \item Enhanced perceptual and cognitive skills
    \item Increased motivation and engagement
    \item Better affective and motivational outcomes
    \item Most effective when integrated with traditional instruction
\end{itemize}

\paragraph*{\citet{papastergiou2009digital} Computer Science Education:}

A study of digital game-based learning in high school computer science found that students using educational games demonstrated:

\begin{itemize}
    \item Significantly higher knowledge acquisition
    \item Greater enjoyment and motivation
    \item Preference for game-based learning over traditional methods
    \item Improved attitudes toward computer science
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Serious Games in Computer Science}
\label{subsec:games-cs-education}

Several successful serious games target computer science education:

\paragraph*{CodeCombat:}
\begin{itemize}
    \item Teaches programming through RPG-style gameplay
    \item Players write real code to control characters
    \item Supports Python, JavaScript, and other languages
    \item Used in thousands of classrooms worldwide
\end{itemize}

\paragraph*{Lightbot:}
\begin{itemize}
    \item Introduces programming concepts through puzzle-solving
    \item Teaches sequencing, loops, and procedures
    \item No syntax required—visual programming interface
    \item Suitable for young learners
\end{itemize}

\paragraph*{Parallel Computing Games:}

Few games specifically target parallel computing education. Notable exceptions include:

\begin{itemize}
    \item \textbf{PARMACS Simulator}: Interactive visualization of parallel algorithms
    \item \textbf{ParSim}: Educational tool for parallel algorithm design
    \item \textbf{CUDA Learning Games}: GPU programming challenges
\end{itemize}

However, these tools typically focus on visualization rather than hands-on, game-like interaction, and few provide multiplayer experiences.

%-----------------------------------------------------------------------
\subsection{Serious Games for HPC Education}
\label{subsec:serious-games-hpc}

High-Performance Computing education faces unique challenges that serious games can address:

\paragraph*{Why Games for HPC?}

\begin{enumerate}
    \item \textbf{Abstract Concepts}: HPC involves invisible processes (threads, messages, synchronization) that are difficult to visualize through static diagrams
    \item \textbf{Temporal Dynamics}: Parallelism involves timing, race conditions, and coordination that unfold over time---games naturally model dynamic systems
    \item \textbf{Scale Mismatch}: Real HPC systems involve millions of operations per second; games can slow down and make these concepts observable
    \item \textbf{Hands-On Experience}: Students learn parallelism best by experiencing coordination challenges firsthand
\end{enumerate}

\paragraph*{Mapping HPC Concepts to Game Mechanics:}
The following mappings enable intuitive understanding of HPC concepts through gameplay (see Table~\ref{tab:hpc-game-mapping}).

\begin{table}[htbp]
    \centering
    \caption{HPC concepts mapped to game mechanics}
    \label{tab:hpc-game-mapping}
    \begin{tabular}{@{}ll@{}}
        \toprule
        \textbf{HPC Concept}   & \textbf{Game Mechanic}                   \\
        \midrule
        Threads/Processes      & Players                                  \\
        Shared Memory          & Shared game board/container              \\
        Thread-Local Storage   & Private player inventory                 \\
        Synchronization        & Turn-taking or barriers                  \\
        Race Conditions        & Conflicting simultaneous actions         \\
        Speedup                & Time comparison (1 player vs. N players) \\
        Communication Overhead & Time to transfer items between players   \\
        Load Balancing         & Equal distribution of work               \\
        \bottomrule
    \end{tabular}
\end{table}

\paragraph*{Advantages of Game-Based HPC Learning:}

\begin{itemize}
    \item \textbf{No Prerequisites}: Students can experience parallel concepts before learning programming syntax
    \item \textbf{Misconception Surfacing}: Games reveal incorrect mental models (e.g., ``more threads always faster'')
    \item \textbf{Quantifiable Learning}: Performance metrics (time, moves) provide concrete feedback
    \item \textbf{Collaborative Learning}: Multiplayer games naturally create discussion and peer learning
    \item \textbf{Scalable Delivery}: Web-based games reach students regardless of institutional HPC infrastructure
\end{itemize}

%-----------------------------------------------------------------------
\section{Web-Based Game Development}
\label{sec:web-game-dev}

Web browsers provide a universal platform for educational game deployment, eliminating installation barriers and enabling access from any device with a modern browser.

%-----------------------------------------------------------------------
\subsection{Web Platform Advantages}
\label{subsec:web-advantages}

\textbf{Accessibility:} Web games require no installation—students access the game via URL, eliminating software distribution challenges and platform compatibility concerns.

\textbf{Cross-Platform:} A single web build runs on Windows, macOS, Linux, and even mobile browsers, maximizing reach with minimal development overhead.

\textbf{Instant Updates:} Deploying updates is immediate—no app store approval processes or user-initiated updates required.

\textbf{Low Barrier:} Modern browsers include powerful JavaScript engines, WebGL for graphics, and APIs for real-time communication.

%-----------------------------------------------------------------------
\subsection{Web Development Challenges}
\label{subsec:web-challenges}

\textbf{Browser Sandboxing:} Security restrictions prevent raw socket access, UDP communication, and local peer discovery—complicating multiplayer networking.

\textbf{Performance Overhead:} WebAssembly and JavaScript have overhead compared to native code, though performance is acceptable for 2D games.

\textbf{Networking Limitations:} Traditional peer-to-peer networking (like WebRTC data channels) can be complex to configure and may not work reliably across all network configurations.

%-----------------------------------------------------------------------
\subsection{Game Engines for Web}
\label{subsec:web-game-engines}

Godot Engine emerged as the optimal choice for this project due to:

\begin{itemize}
    \item Completely free and open-source (MIT license)
    \item Excellent 2D rendering performance
    \item Lightweight web exports (smaller than Unity or Unreal)
    \item GDScript language similar to Python (accessible for students)
    \item Active community and extensive documentation
    \item Built-in HTML5 export templates
    \item Scene-based architecture promotes modular design
\end{itemize}

%-----------------------------------------------------------------------
\section{Multiplayer Game Architecture}
\label{sec:bg-multiplayer-architecture}

Multiplayer functionality is essential for simulating OpenMP shared-memory parallelism with multiple players collaborating on shared data. This section reviews common multiplayer architectures and networking technologies.

%-----------------------------------------------------------------------
\subsection{Client-Server Architecture}
\label{subsec:client-server}

Traditional multiplayer games use a client-server model:

\textbf{Characteristics:}
\begin{itemize}
    \item Dedicated server hosts game state
    \item Clients send inputs to server
    \item Server validates actions, updates state, broadcasts to clients
    \item Authoritative server prevents cheating
    \item Requires server infrastructure and maintenance
\end{itemize}

\textbf{Advantages:}
\begin{itemize}
    \item Strong consistency and cheat prevention
    \item Clients need not communicate directly
    \item Server can enforce rules and validate actions
\end{itemize}

\textbf{Disadvantages:}
\begin{itemize}
    \item Requires dedicated servers (cost, maintenance)
    \item Single point of failure
    \item Latency for all communications
    \item Scalability challenges with many concurrent games
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Peer-to-Peer Architecture}
\label{subsec:p2p}

Peer-to-peer (P2P) networks eliminate dedicated servers by allowing clients to communicate directly:

\textbf{Characteristics:}
\begin{itemize}
    \item Clients connect directly to each other
    \item No central server required (except for matchmaking)
    \item One peer often designated as ``host'' for authority
    \item Lower latency for direct connections
    \item More complex connection establishment (NAT traversal)
\end{itemize}

\textbf{Advantages:}
\begin{itemize}
    \item No server infrastructure costs
    \item Lower latency between peers
    \item Decentralized—no single point of failure
    \item Scalable for small groups (2--8 players)
\end{itemize}

\textbf{Disadvantages:}
\begin{itemize}
    \item NAT traversal complexity
    \item Host has performance burden
    \item Cheat prevention more difficult
    \item Connection quality varies with peer networks
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Web Transport Technologies}
\label{subsec:web-transport}

Web browsers offer several options for real-time communication, each with trade-offs:

\paragraph*{HTTP Polling:}
\begin{itemize}
    \item Client repeatedly requests updates from server
    \item Simple to implement, universally supported
    \item Higher latency and server load due to frequent requests
    \item Suitable for low-frequency updates
\end{itemize}

\paragraph*{Server-Sent Events (SSE):}
\begin{itemize}
    \item Server pushes events to client over HTTP
    \item Simpler than WebSocket (HTTP-based, no special protocol)
    \item Unidirectional (server to client only)
    \item Automatic reconnection built into browser API
    \item Good browser support and proxy compatibility
\end{itemize}

\paragraph*{HTTP + SSE Relay Architecture:}

For web-based multiplayer games requiring broad browser compatibility, a relay server architecture using HTTP POST for client-to-server communication and SSE for server-to-client events provides:

\begin{itemize}
    \item Universal browser support without WebSocket complexity
    \item Works through firewalls and proxies that block WebSocket
    \item Simplified connection establishment (no STUN/TURN required)
    \item Trade-off: All traffic routes through server (no P2P)
    \item Acceptable latency for turn-based or slower-paced games
\end{itemize}

%-----------------------------------------------------------------------
\subsection{State Synchronization Patterns}
\label{subsec:state-sync}

Maintaining consistent game state across multiple clients is challenging. Common patterns include:

\paragraph*{Deterministic Lockstep:}
\begin{itemize}
    \item All clients simulate the same game logic
    \item Inputs synchronized and executed simultaneously
    \item Guarantees identical state on all clients
    \item Sensitive to latency and packet loss
    \item Used in RTS games (Age of Empires, StarCraft)
\end{itemize}

\paragraph*{Client-Side Prediction:}
\begin{itemize}
    \item Clients predict results of actions immediately
    \item Server validates and corrects if necessary
    \item Provides responsive feel despite latency
    \item Requires reconciliation when predictions wrong
    \item Used in FPS games (Counter-Strike, Overwatch)
\end{itemize}

\paragraph*{Authoritative Server/Host:}
\begin{itemize}
    \item Server/host maintains canonical state
    \item Clients send actions, receive state updates
    \item Simple to implement and reason about
    \item Higher latency but stronger consistency
    \item Suitable for turn-based or slower-paced games
\end{itemize}

\paragraph*{Selected Approach:}

For the HPC Sorting Game, a \textbf{host-authoritative model} was chosen because:

\begin{itemize}
    \item Educational focus prioritizes clarity over competitive performance
    \item Collaborative nature tolerates moderate latency
    \item Simpler implementation reduces development complexity
    \item Prevents inconsistencies and ensures fair learning environment
    \item Aligns with centralized coordination patterns in parallel systems
\end{itemize}

%-----------------------------------------------------------------------
\section{Related Work}
\label{sec:related-work}

This section reviews existing educational tools and games related to parallel computing and serious games.

%-----------------------------------------------------------------------
\subsection{Parallel Computing Educational Tools}
\label{subsec:parallel-tools}

Several tools exist for teaching parallel computing, each with strengths and limitations:

\paragraph*{PARMACS:}
\begin{itemize}
    \item Parallel algorithm visualization tool
    \item Shows thread/process execution timelines
    \item Limited interactivity—primarily observational
    \item Desktop-only platform
\end{itemize}

\paragraph*{OpenMP Visualization Tools:}
\begin{itemize}
    \item Intel VTune, TAU (Tuning and Analysis Utilities)
    \item Focused on performance profiling
    \item Steep learning curve for students
    \item Not designed for introductory education
\end{itemize}

\paragraph*{MPI Tools:}
\begin{itemize}
    \item MPICH, Open MPI with debugging tools
    \item Require cluster access or virtual machines
    \item Focus on actual parallel programming, not conceptual learning
    \item \textit{Note: MPI concepts discussed for context; not covered in this thesis}
\end{itemize}

\paragraph*{Gap Identification:}

Existing tools generally fall into two categories:

\begin{enumerate}
    \item \textbf{Visualization tools}: Show parallel execution but lack hands-on interaction
    \item \textbf{Programming environments}: Require coding skills, deterring beginners
\end{enumerate}

Few tools bridge the gap between conceptual understanding and practical implementation. Fewer still are designed for web platforms or incorporate game mechanics to enhance engagement.

%-----------------------------------------------------------------------
\subsection{Serious Games for Computing Education}
\label{subsec:cs-games}

Several serious games successfully teach computing concepts:

\paragraph*{CodeCombat:}
\begin{itemize}
    \item Teaches programming through RPG gameplay
    \item Players write real code in Python/JavaScript
    \item Excellent for syntax and basic algorithms
    \item Does not address parallel computing
\end{itemize}

\paragraph*{Human Resource Machine:}
\begin{itemize}
    \item Puzzle game teaching assembly-like programming
    \item Visual programming—no syntax barriers
    \item Excellent for teaching sequential thinking
    \item Single-threaded—no parallelism concepts
\end{itemize}

\paragraph*{Shenzhen I/O:}
\begin{itemize}
    \item Hardware design and programming game
    \item Teaches low-level optimization
    \item Complex and targeted at experienced programmers
    \item No explicit parallel computing focus
\end{itemize}

\paragraph*{Gap in Parallel Computing Games:}

No widely-adopted serious game specifically teaches parallel computing concepts like OpenMP shared-memory parallelism through interactive, game-based mechanics on web platforms. This gap motivated the development of the HPC Sorting Serious Game, which focuses on OpenMP concepts with potential for future MPI extensions.

%-----------------------------------------------------------------------
\subsection{Physical Teaching Methods}
\label{subsec:physical-methods}

The pedagogical approach for this thesis draws inspiration from physical classroom activities:

\paragraph*{CS Unplugged:}
\begin{itemize}
    \item Collection of unplugged computer science activities
    \item Teaches algorithms, sorting, searching without computers
    \item Highly engaging but not scalable or repeatable
    \item Limited to in-person classroom settings
\end{itemize}

\paragraph*{Professor D'Agostino's Card Sorting Experiments:}

As described in Chapter~\ref{ch:introduction}, Professor Daniele D'Agostino conducted classroom experiments where students physically sorted numbered cards to simulate parallel computing paradigms. These experiments demonstrated:

\begin{itemize}
    \item High student engagement and retention
    \item Intuitive understanding of parallelism concepts
    \item Memorable hands-on experience
    \item Clear differentiation between sequential and parallel execution models
\end{itemize}

However, physical experiments have limitations:

\begin{itemize}
    \item Require physical classroom presence
    \item Not scalable to large classes
    \item Difficult to reproduce consistently
    \item Limited flexibility in parameters (card count, student count)
    \item No performance metrics or automated feedback
\end{itemize}

\paragraph*{Digital Transformation:}

This thesis aims to capture the pedagogical effectiveness of physical card-sorting experiments in a digital, web-first serious game that overcomes the limitations of physical activities while preserving their educational benefits.

%-----------------------------------------------------------------------
\section{Summary}
\label{sec:background-summary}

This chapter established the foundational knowledge necessary to understand the HPC Sorting Serious Game:

\begin{itemize}
    \item \textbf{Parallel Computing}: Reviewed OpenMP shared-memory parallelism (the focus of this thesis) and MPI distributed-memory paradigms (for context), highlighting their educational challenges and importance.

    \item \textbf{Serious Games}: Examined theoretical foundations, empirical evidence, and successful examples of game-based learning in computer science education.

    \item \textbf{Web Development}: Discussed advantages and challenges of web platforms for educational games, and the rationale for selecting Godot Engine with web export capabilities.

    \item \textbf{Multiplayer Architecture}: Compared client-server and peer-to-peer models, introduced web transport technologies (HTTP/SSE), and justified the host-authoritative approach for OpenMP simulation.

    \item \textbf{Related Work}: Identified gaps in existing parallel computing educational tools and serious games, motivating the development of this project.
\end{itemize}

The next chapter describes the research methodology, requirements analysis, and technology selection decisions that guided the development of the HPC Sorting Serious Game.
