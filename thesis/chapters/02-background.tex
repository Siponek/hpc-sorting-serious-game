\chapter{Background and Literature Review}
\label{ch:background}

This chapter provides the foundational knowledge and contextual background necessary to understand the HPC Sorting Serious Game. We review key concepts in parallel computing, serious games in education, mobile game development, and multiplayer networking architectures.

%----------------------------------------------------------------------------------------
\section{Parallel Computing Fundamentals}
\label{sec:parallel-computing}

Parallel computing is the simultaneous execution of multiple computational tasks to solve problems more efficiently than sequential processing. As Moore's Law approaches its physical limits, parallel computing has become essential for improving computational performance across scientific computing, data analytics, and real-time systems.

%----------------------------------------------------------------------------------------
\subsection{Parallel Programming Paradigms}
\label{subsec:parallel-paradigms}

Two primary paradigms dominate parallel computing education and practice: shared-memory parallelism and distributed-memory parallelism.

\subsubsection{Shared-Memory Parallelism}

In shared-memory systems, multiple processors or cores access a common address space. All threads can read and write to the same memory locations, enabling efficient data sharing but requiring careful synchronization to prevent race conditions.

\paragraph{Characteristics:}
\begin{itemize}
    \item All processors access the same physical memory
    \item Communication occurs through shared variables
    \item Synchronization primitives (locks, barriers, atomic operations) prevent conflicts
    \item Lower communication overhead compared to distributed memory
    \item Limited scalability due to memory bandwidth constraints
\end{itemize}

\paragraph{Applications:}
Shared-memory parallelism is ideal for problems requiring frequent communication between processing units, such as iterative algorithms, graph processing, and data analytics on multicore processors.

\subsubsection{Distributed-Memory Parallelism}

In distributed-memory systems, each processor has its own local memory. Processors communicate by explicitly sending and receiving messages over a network, requiring programmers to manage data distribution and communication patterns.

\paragraph{Characteristics:}
\begin{itemize}
    \item Each processor has private memory space
    \item Communication requires explicit message passing
    \item Scalable to thousands or millions of processors
    \item Higher communication overhead and latency
    \item No shared state eliminates race conditions but complicates programming
\end{itemize}

\paragraph{Applications:}
Distributed-memory parallelism is essential for large-scale scientific simulations, weather modeling, molecular dynamics, and big data processing across cluster and supercomputer architectures.

%----------------------------------------------------------------------------------------
\subsection{OpenMP: Shared-Memory Programming}
\label{subsec:openmp}

OpenMP (Open Multi-Processing) is a widely-used API for shared-memory parallel programming in C, C++, and Fortran. It uses compiler directives (pragmas) to specify parallel regions, enabling incremental parallelization of sequential code.

\paragraph{Core Concepts:}

\begin{description}
    \item[Parallel Regions] Code sections executed by multiple threads simultaneously
    \item[Work-Sharing Constructs] Distribute loop iterations or tasks among threads
    \item[Data Scoping] Variables can be shared (visible to all threads) or private (thread-local copies)
    \item[Synchronization] Barriers, critical sections, and atomic operations coordinate thread execution
    \item[Scheduling] Strategies (static, dynamic, guided) control how iterations are assigned to threads
\end{description}

\paragraph{Example Code:}

\begin{lstlisting}[language=C++, caption={Simple OpenMP parallel loop}]
#pragma omp parallel for schedule(dynamic)
for (int i = 0; i < N; i++) {
    array[i] = compute_value(i);
}
\end{lstlisting}

\paragraph{Educational Value:}

OpenMP's simplicity makes it excellent for teaching parallel programming concepts. The incremental approach—starting with sequential code and adding pragmas—allows students to observe immediate performance improvements while learning about thread management, data dependencies, and race conditions.

%----------------------------------------------------------------------------------------
\subsection{MPI: Distributed-Memory Programming}
\label{subsec:mpi}

MPI (Message Passing Interface) is the de facto standard for distributed-memory parallel programming. It provides a rich set of communication primitives for sending and receiving messages between processes, enabling scalable parallel computing on clusters and supercomputers.

\paragraph{Core Operations:}

\begin{description}
    \item[Point-to-Point Communication] \texttt{MPI\_Send} and \texttt{MPI\_Recv} exchange messages between specific processes
    \item[Collective Communication] Operations like \texttt{MPI\_Bcast}, \texttt{MPI\_Gather}, and \texttt{MPI\_Reduce} involve all processes in a communicator
    \item[Process Groups] Communicators organize processes and define communication contexts
    \item[Data Types] MPI supports both primitive and user-defined data types for message content
\end{description}

\paragraph{Example Code:}

\begin{lstlisting}[language=C++, caption={Simple MPI message passing}]
MPI_Init(&argc, &argv);
int rank, size;
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
MPI_Comm_size(MPI_COMM_WORLD, &size);

if (rank == 0) {
    // Master process
    MPI_Send(data, count, MPI_INT, 1, 0, MPI_COMM_WORLD);
} else if (rank == 1) {
    // Worker process
    MPI_Recv(data, count, MPI_INT, 0, 0, MPI_COMM_WORLD, &status);
}

MPI_Finalize();
\end{lstlisting}

\paragraph{Educational Value:}

MPI teaches students about distributed computing challenges including data distribution, explicit communication, latency management, and scalability. The message-passing model forces programmers to think carefully about data ownership and communication patterns, skills essential for modern distributed systems.

%----------------------------------------------------------------------------------------
\subsection{Parallel Sorting Algorithms}
\label{subsec:parallel-sorting}

Sorting is a fundamental algorithmic problem that benefits significantly from parallelization. Several parallel sorting strategies exist, each with different communication and synchronization requirements.

\paragraph{Parallel Merge Sort:}
\begin{itemize}
    \item Recursively divide array into subarrays
    \item Sort subarrays in parallel
    \item Merge sorted subarrays (potentially in parallel)
    \item Well-suited for shared-memory systems
    \item Time complexity: $O(\frac{n \log n}{p})$ with $p$ processors
\end{itemize}

\paragraph{Sample Sort (MPI Pattern):}
\begin{itemize}
    \item Distribute data across processes
    \item Each process sorts local data
    \item Select sample elements to determine global pivots
    \item Redistribute data based on pivots
    \item Each process sorts its final partition
    \item Commonly used in distributed-memory systems
\end{itemize}

\paragraph{Relevance to Educational Game:}

The card-sorting game mechanics directly map to parallel sorting algorithms. Players acting as threads (OpenMP) or processes (MPI) must coordinate to sort cards efficiently, making abstract algorithmic concepts tangible through gameplay.

%----------------------------------------------------------------------------------------
\section{Serious Games in Education}
\label{sec:serious-games}

Serious games—games designed primarily for purposes beyond entertainment—have emerged as powerful educational tools. This section reviews the theoretical foundations and empirical evidence supporting game-based learning.

%----------------------------------------------------------------------------------------
\subsection{Definition and Characteristics}
\label{subsec:serious-games-definition}

\citet{zyda2005visual} defines serious games as games that ``do not have entertainment, enjoyment, or fun as their primary purpose.'' These games leverage game design principles to achieve learning objectives, skill development, or behavioral change.

\paragraph{Key Characteristics:}

\begin{itemize}
    \item \textbf{Clear Learning Objectives}: Explicit educational goals aligned with curricula
    \item \textbf{Engaging Mechanics}: Game elements (challenges, rewards, feedback) maintain motivation
    \item \textbf{Active Learning}: Players learn by doing, not passive observation
    \item \textbf{Immediate Feedback}: Instant consequences of actions reinforce learning
    \item \textbf{Safe Experimentation}: Risk-free environment for trial and error
    \item \textbf{Progressive Difficulty}: Challenges scale with player skill development
\end{itemize}

%----------------------------------------------------------------------------------------
\subsection{Theoretical Foundations}
\label{subsec:game-based-learning-theory}

Game-based learning draws on several established educational theories:

\subsubsection{Constructivism}

Constructivist theory posits that learners actively construct knowledge through experience rather than passively receiving information. Games naturally support constructivist learning by placing players in problem-solving scenarios where they discover principles through experimentation.

\subsubsection{Flow Theory}

\citet{csikszentmihalyi1990flow} describes ``flow'' as the optimal psychological state where challenge level matches skill level, producing deep engagement. Well-designed educational games maintain flow by dynamically adjusting difficulty, keeping learners in the zone of proximal development.

\subsubsection{Experiential Learning}

Kolb's experiential learning cycle—concrete experience, reflective observation, abstract conceptualization, active experimentation—aligns perfectly with game mechanics. Players experience situations, observe outcomes, form hypotheses, and test them iteratively.

%----------------------------------------------------------------------------------------
\subsection{Empirical Evidence}
\label{subsec:serious-games-evidence}

Research consistently demonstrates the effectiveness of serious games for learning:

\paragraph{\citet{connolly2012systematic} Meta-Analysis:}

A systematic literature review of 129 papers found that serious games positively impact learning outcomes across multiple domains. Key findings include:

\begin{itemize}
    \item Improved knowledge acquisition and retention
    \item Enhanced perceptual and cognitive skills
    \item Increased motivation and engagement
    \item Better affective and motivational outcomes
    \item Most effective when integrated with traditional instruction
\end{itemize}

\paragraph{\citet{papastergiou2009digital} Computer Science Education:}

A study of digital game-based learning in high school computer science found that students using educational games demonstrated:

\begin{itemize}
    \item Significantly higher knowledge acquisition
    \item Greater enjoyment and motivation
    \item Preference for game-based learning over traditional methods
    \item Improved attitudes toward computer science
\end{itemize}

%----------------------------------------------------------------------------------------
\subsection{Serious Games in Computer Science}
\label{subsec:games-cs-education}

Several successful serious games target computer science education:

\paragraph{CodeCombat:}
\begin{itemize}
    \item Teaches programming through RPG-style gameplay
    \item Players write real code to control characters
    \item Supports Python, JavaScript, and other languages
    \item Used in thousands of classrooms worldwide
\end{itemize}

\paragraph{Lightbot:}
\begin{itemize}
    \item Introduces programming concepts through puzzle-solving
    \item Teaches sequencing, loops, and procedures
    \item No syntax required—visual programming interface
    \item Suitable for young learners
\end{itemize}

\paragraph{Parallel Computing Games:}

Few games specifically target parallel computing education. Notable exceptions include:

\begin{itemize}
    \item \textbf{PARMACS Simulator}: Interactive visualization of parallel algorithms
    \item \textbf{ParSim}: Educational tool for parallel algorithm design
    \item \textbf{CUDA Learning Games}: GPU programming challenges
\end{itemize}

However, these tools typically focus on visualization rather than hands-on, game-like interaction, and few target mobile platforms or provide multiplayer experiences.

%----------------------------------------------------------------------------------------
\section{Mobile Game Development}
\label{sec:mobile-game-dev}

Mobile platforms present unique opportunities and challenges for educational game development.

%----------------------------------------------------------------------------------------
\subsection{Mobile Platform Advantages}
\label{subsec:mobile-advantages}

\paragraph{Ubiquity:}
Smartphones are nearly universal in developed countries. Students already carry powerful computing devices, eliminating barriers to access.

\paragraph{Accessibility:}
Mobile games enable learning anywhere, anytime—during commutes, study sessions, or breaks—supporting flexible, self-paced education.

\paragraph{Touch Interfaces:}
Direct manipulation through touch is intuitive and natural, reducing the learning curve compared to keyboard/mouse interfaces or command-line tools.

\paragraph{Social Integration:}
Mobile platforms naturally support multiplayer experiences, social sharing, and collaborative learning through built-in connectivity.

%----------------------------------------------------------------------------------------
\subsection{Mobile Development Challenges}
\label{subsec:mobile-challenges}

\paragraph{Screen Real Estate:}

Displaying complex information on 5--7 inch screens requires careful UI design. Educational games must balance information density with usability.

\paragraph{Performance Constraints:}

Mobile devices have limited CPU, GPU, memory, and battery resources compared to desktops. Games must optimize rendering, minimize network usage, and manage power consumption.

\paragraph{Platform Fragmentation:}

Android devices vary widely in screen size, resolution, OS version, and hardware capabilities. iOS is more uniform but still requires adaptive design.

\paragraph{Input Limitations:}

Touch input lacks the precision of mouse pointers and the expressiveness of keyboards. Drag-and-drop interactions must accommodate finger size and occlusion.

%----------------------------------------------------------------------------------------
\subsection{Game Engines for Mobile}
\label{subsec:mobile-game-engines}

Several game engines support mobile development with varying trade-offs:

\begin{table}[htbp]
    \centering
    \caption{Comparison of mobile game engines}
    \label{tab:mobile-engines}
    \begin{tabular}{@{}lllll@{}}
        \toprule
        \textbf{Engine} & \textbf{License} & \textbf{Languages} & \textbf{2D Support} & \textbf{Learning Curve} \\
        \midrule
        Unity           & Proprietary      & C\#                & Good                & Medium                  \\
        Unreal          & Proprietary      & C++/Blueprints     & Fair                & Steep                   \\
        Godot           & Open Source      & GDScript/C++       & Excellent           & Gentle                  \\
        Cocos2d         & Open Source      & C++/Lua            & Excellent           & Medium                  \\
        \bottomrule
    \end{tabular}
\end{table}

\paragraph{Godot Engine:}

Godot emerged as the optimal choice for this project due to:

\begin{itemize}
    \item Completely free and open-source (MIT license)
    \item Excellent 2D rendering performance
    \item Lightweight engine suitable for mobile targets
    \item GDScript language similar to Python (accessible for students)
    \item Active community and extensive documentation
    \item Built-in export templates for Android and iOS
    \item Scene-based architecture promotes modular design
\end{itemize}

%----------------------------------------------------------------------------------------
\section{Multiplayer Game Architecture}
\label{sec:multiplayer-architecture}

Multiplayer functionality is essential for simulating distributed computing scenarios like MPI. This section reviews common multiplayer architectures and networking technologies.

%----------------------------------------------------------------------------------------
\subsection{Client-Server Architecture}
\label{subsec:client-server}

Traditional multiplayer games use a client-server model:

\paragraph{Characteristics:}
\begin{itemize}
    \item Dedicated server hosts game state
    \item Clients send inputs to server
    \item Server validates actions, updates state, broadcasts to clients
    \item Authoritative server prevents cheating
    \item Requires server infrastructure and maintenance
\end{itemize}

\paragraph{Advantages:}
\begin{itemize}
    \item Strong consistency and cheat prevention
    \item Clients need not communicate directly
    \item Server can enforce rules and validate actions
\end{itemize}

\paragraph{Disadvantages:}
\begin{itemize}
    \item Requires dedicated servers (cost, maintenance)
    \item Single point of failure
    \item Latency for all communications
    \item Scalability challenges with many concurrent games
\end{itemize}

%----------------------------------------------------------------------------------------
\subsection{Peer-to-Peer Architecture}
\label{subsec:p2p}

Peer-to-peer (P2P) networks eliminate dedicated servers by allowing clients to communicate directly:

\paragraph{Characteristics:}
\begin{itemize}
    \item Clients connect directly to each other
    \item No central server required (except for matchmaking)
    \item One peer often designated as ``host'' for authority
    \item Lower latency for direct connections
    \item More complex connection establishment (NAT traversal)
\end{itemize}

\paragraph{Advantages:}
\begin{itemize}
    \item No server infrastructure costs
    \item Lower latency between peers
    \item Decentralized—no single point of failure
    \item Scalable for small groups (2--8 players)
\end{itemize}

\paragraph{Disadvantages:}
\begin{itemize}
    \item NAT traversal complexity
    \item Host has performance burden
    \item Cheat prevention more difficult
    \item Connection quality varies with peer networks
\end{itemize}

%----------------------------------------------------------------------------------------
\subsection{WebRTC for Game Networking}
\label{subsec:webrtc}

WebRTC (Web Real-Time Communication) is a modern technology for P2P communication in browsers and applications:

\paragraph{Key Features:}
\begin{itemize}
    \item Peer-to-peer data channels with low latency
    \item Built-in NAT traversal (STUN/TURN)
    \item Encrypted communication (DTLS)
    \item No plugins required—native browser support
    \item Available in mobile platforms (Android, iOS)
\end{itemize}

\paragraph{Connection Process:}
\begin{enumerate}
    \item Peers exchange connection information (Session Description Protocol)
    \item STUN servers discover public IP addresses
    \item ICE (Interactive Connectivity Establishment) negotiates optimal connection path
    \item TURN servers relay traffic if direct connection impossible
    \item Encrypted data channels established
\end{enumerate}

\paragraph{Suitability for Educational Games:}

WebRTC is ideal for educational multiplayer games because:

\begin{itemize}
    \item No server costs for gameplay (only signaling)
    \item Low latency enables real-time interaction
    \item Cross-platform support (mobile, web, desktop)
    \item Open standard with good library support
    \item Secure by default
\end{itemize}

%----------------------------------------------------------------------------------------
\subsection{State Synchronization Patterns}
\label{subsec:state-sync}

Maintaining consistent game state across multiple clients is challenging. Common patterns include:

\paragraph{Deterministic Lockstep:}
\begin{itemize}
    \item All clients simulate the same game logic
    \item Inputs synchronized and executed simultaneously
    \item Guarantees identical state on all clients
    \item Sensitive to latency and packet loss
    \item Used in RTS games (Age of Empires, StarCraft)
\end{itemize}

\paragraph{Client-Side Prediction:}
\begin{itemize}
    \item Clients predict results of actions immediately
    \item Server validates and corrects if necessary
    \item Provides responsive feel despite latency
    \item Requires reconciliation when predictions wrong
    \item Used in FPS games (Counter-Strike, Overwatch)
\end{itemize}

\paragraph{Authoritative Server/Host:}
\begin{itemize}
    \item Server/host maintains canonical state
    \item Clients send actions, receive state updates
    \item Simple to implement and reason about
    \item Higher latency but stronger consistency
    \item Suitable for turn-based or slower-paced games
\end{itemize}

\paragraph{Selected Approach:}

For the HPC Sorting Game, a \textbf{host-authoritative model} was chosen because:

\begin{itemize}
    \item Educational focus prioritizes clarity over competitive performance
    \item Turn-based nature tolerates moderate latency
    \item Simpler implementation reduces development complexity
    \item Prevents cheating and ensures fair learning environment
    \item Aligns with MPI master-worker pattern being taught
\end{itemize}

%----------------------------------------------------------------------------------------
\section{Related Work}
\label{sec:related-work}

This section reviews existing educational tools and games related to parallel computing and serious games.

%----------------------------------------------------------------------------------------
\subsection{Parallel Computing Educational Tools}
\label{subsec:parallel-tools}

Several tools exist for teaching parallel computing, each with strengths and limitations:

\paragraph{PARMACS:}
\begin{itemize}
    \item Parallel algorithm visualization tool
    \item Shows thread/process execution timelines
    \item Limited interactivity—primarily observational
    \item Desktop-only platform
\end{itemize}

\paragraph{OpenMP Visualization Tools:}
\begin{itemize}
    \item Intel VTune, TAU (Tuning and Analysis Utilities)
    \item Focused on performance profiling
    \item Steep learning curve for students
    \item Not designed for introductory education
\end{itemize}

\paragraph{MPI Simulators:}
\begin{itemize}
    \item MPICH, Open MPI with debugging tools
    \item Require cluster access or virtual machines
    \item Focus on actual parallel programming, not conceptual learning
\end{itemize}

\paragraph{Gap Identification:}

Existing tools generally fall into two categories:

\begin{enumerate}
    \item \textbf{Visualization tools}: Show parallel execution but lack hands-on interaction
    \item \textbf{Programming environments}: Require coding skills, deterring beginners
\end{enumerate}

Few tools bridge the gap between conceptual understanding and practical implementation. Fewer still are designed for mobile platforms or incorporate game mechanics to enhance engagement.

%----------------------------------------------------------------------------------------
\subsection{Serious Games for Computing Education}
\label{subsec:cs-games}

Several serious games successfully teach computing concepts:

\paragraph{CodeCombat:}
\begin{itemize}
    \item Teaches programming through RPG gameplay
    \item Players write real code in Python/JavaScript
    \item Excellent for syntax and basic algorithms
    \item Does not address parallel computing
\end{itemize}

\paragraph{Human Resource Machine:}
\begin{itemize}
    \item Puzzle game teaching assembly-like programming
    \item Visual programming—no syntax barriers
    \item Excellent for teaching sequential thinking
    \item Single-threaded—no parallelism concepts
\end{itemize}

\paragraph{Shenzhen I/O:}
\begin{itemize}
    \item Hardware design and programming game
    \item Teaches low-level optimization
    \item Complex and targeted at experienced programmers
    \item No explicit parallel computing focus
\end{itemize}

\paragraph{Gap in Parallel Computing Games:}

No widely-adopted serious game specifically teaches parallel computing concepts like OpenMP and MPI through interactive, game-based mechanics on mobile platforms. This gap motivated the development of the HPC Sorting Serious Game.

%----------------------------------------------------------------------------------------
\subsection{Physical Teaching Methods}
\label{subsec:physical-methods}

The pedagogical approach for this thesis draws inspiration from physical classroom activities:

\paragraph{CS Unplugged:}
\begin{itemize}
    \item Collection of unplugged computer science activities
    \item Teaches algorithms, sorting, searching without computers
    \item Highly engaging but not scalable or repeatable
    \item Limited to in-person classroom settings
\end{itemize}

\paragraph{Professor D'Agostino's Card Sorting Experiments:}

As described in Chapter~\ref{ch:introduction}, Professor Daniele D'Agostino conducted classroom experiments where students physically sorted numbered cards to simulate parallel computing paradigms. These experiments demonstrated:

\begin{itemize}
    \item High student engagement and retention
    \item Intuitive understanding of parallelism concepts
    \item Memorable hands-on experience
    \item Clear differentiation between OpenMP and MPI models
\end{itemize}

However, physical experiments have limitations:

\begin{itemize}
    \item Require physical classroom presence
    \item Not scalable to large classes
    \item Difficult to reproduce consistently
    \item Limited flexibility in parameters (card count, student count)
    \item No performance metrics or automated feedback
\end{itemize}

\paragraph{Digital Transformation:}

This thesis aims to capture the pedagogical effectiveness of physical card-sorting experiments in a digital, web-first serious game that overcomes the limitations of physical activities while preserving their educational benefits.

%----------------------------------------------------------------------------------------
\section{Summary}
\label{sec:background-summary}

This chapter established the foundational knowledge necessary to understand the HPC Sorting Serious Game:

\begin{itemize}
    \item \textbf{Parallel Computing}: Reviewed OpenMP (shared-memory) and MPI (distributed-memory) paradigms, highlighting their educational challenges and importance.

    \item \textbf{Serious Games}: Examined theoretical foundations, empirical evidence, and successful examples of game-based learning in computer science education.

    \item \textbf{Mobile Development}: Discussed advantages and challenges of mobile platforms for educational games, and the rationale for selecting Godot Engine.

    \item \textbf{Multiplayer Architecture}: Compared client-server and peer-to-peer models, introduced WebRTC, and justified the host-authoritative approach.

    \item \textbf{Related Work}: Identified gaps in existing parallel computing educational tools and serious games, motivating the development of this project.
\end{itemize}

The next chapter describes the research methodology, requirements analysis, and technology selection decisions that guided the development of the HPC Sorting Serious Game.
