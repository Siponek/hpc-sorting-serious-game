\chapter{Methodology}
\label{ch:methodology}

This chapter describes the research methodology, requirements analysis, design approach, and technology selection decisions that guided the development of the HPC Sorting Serious Game. The methodology follows a Design Science Research approach, emphasizing iterative development and evaluation.

%-----------------------------------------------------------------------
\section{Research Methodology}
\label{sec:research-methodology}

%-----------------------------------------------------------------------
\subsection{Design Science Research Framework}
\label{subsec:design-science}

This thesis adopts the Design Science Research (DSR) methodology \citep{hevner2004design, peffers2007design}, which is particularly well-suited for developing innovative artifacts that address practical problems while contributing to theoretical knowledge.

\paragraph*{DSR Process Model:}

The DSR process consists of six iterative activities:

\begin{enumerate}
    \item \textbf{Problem Identification and Motivation}: Identify the research problem (teaching HPC concepts) and justify the value of a solution (web-based serious game).

    \item \textbf{Define Objectives of a Solution}: Infer solution objectives from problem definition and existing knowledge (create engaging, accessible, educational multiplayer game).

    \item \textbf{Design and Development}: Create the artifact (HPC Sorting Serious Game) by selecting appropriate technologies and implementing game mechanics.

    \item \textbf{Demonstration}: Demonstrate the artifact's utility by applying it to the problem context (students learning parallel computing).

    \item \textbf{Evaluation}: Observe and measure how well the artifact supports a solution to the problem (usability testing, performance benchmarking).

    \item \textbf{Communication}: Communicate the problem, artifact, evaluation, and contributions to relevant audiences (thesis, potential publications).
\end{enumerate}

\paragraph*{Rationale for DSR:}

DSR is appropriate for this research because:

\begin{itemize}
    \item The goal is to create a functional artifact (serious game) rather than merely analyze existing phenomena
    \item The problem is practical and relevant to HPC education
    \item The solution requires integrating knowledge from multiple domains (pedagogy, game design, parallel computing, web development)
    \item Evaluation can be both utility-based (does it work?) and design-based (is it well-constructed?)
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Development Approach}
\label{subsec:development-approach}

The game development followed an iterative, incremental approach:

\paragraph*{Phase 1: Concept and Prototyping (Weeks 1--3)}
\begin{itemize}
    \item Defined core mechanics based on physical card-sorting experiments
    \item Created paper prototypes and mockups
    \item Evaluated technology options (game engines, frameworks)
    \item Developed minimal prototype with basic card rendering
\end{itemize}

\paragraph*{Phase 2: Single-Player Implementation (Weeks 4--7)}
\begin{itemize}
    \item Implemented card generation, shuffling, and rendering
    \item Developed drag-and-drop mechanics for touch and mouse input
    \item Created buffer zones for private card storage
    \item Implemented sorting validation and game completion logic
    \item Added timer and move counting
\end{itemize}

\paragraph*{Phase 3: Multiplayer Foundation (Weeks 8--12)}
\begin{itemize}
    \item Developed HTTP/SSE relay server for web browser compatibility
    \item Implemented lobby system for matchmaking
    \item Developed basic state synchronization
    \item Integrated GDSync framework with custom web transport layer
    \item Tested connection establishment and stability
\end{itemize}

\paragraph*{Phase 4: Multiplayer Refinement (Weeks 13--16)}
\begin{itemize}
    \item Implemented card visibility management (private buffers)
    \item Developed host-authoritative state management
    \item Added disconnection handling and recovery
    \item Refined synchronization for card movements
    \item Addressed framework issues (GDSync protected mode)
\end{itemize}

\paragraph*{Phase 5: Polish and Testing (Weeks 17--20)}
\begin{itemize}
    \item UI/UX improvements for web usability
    \item Performance optimization (rendering, networking)
    \item Extensive testing across web browsers
    \item Documentation and code cleanup
    \item Preparation for evaluation and thesis writing
\end{itemize}

%-----------------------------------------------------------------------
\section{Requirements Analysis}
\label{sec:requirements}

A comprehensive requirements analysis was conducted to ensure the game met educational and functional objectives.

%-----------------------------------------------------------------------
\subsection{Educational Requirements}
\label{subsec:educational-requirements}

The primary purpose of the game is education. Requirements were derived from HPC learning objectives and parallel computing curricula:

\paragraph*{ER1: OpenMP Simulation}
\begin{itemize}
    \item The game must simulate shared-memory parallelism
    \item All players must see all cards in the main container (shared memory)
    \item Players must have private buffers (thread-local storage)
    \item No explicit communication required between players (implicit synchronization)
\end{itemize}

\paragraph*{ER2: Sequential Execution Baseline}
\begin{itemize}
    \item The game must provide a single-player mode for sequential execution comparison
    \item A single player must sort all cards without parallelism
    \item This mode serves as a baseline for understanding speedup from parallelization
    \item Players should be able to compare sequential vs. parallel performance
\end{itemize}

\paragraph*{ER3: Performance Feedback}
\begin{itemize}
    \item The game must provide timing information (simulating speedup measurement)
    \item Move counting must encourage algorithmic efficiency
    \item Visual feedback must reinforce correct and incorrect actions
\end{itemize}

\paragraph*{ER4: Progressive Difficulty}
\begin{itemize}
    \item Support variable numbers of cards (10--200) for scalability lessons
    \item Support variable numbers of players (2--4) for parallelism degree
    \item Provide different sorting challenges (random, partially sorted, reverse sorted)
\end{itemize}

\paragraph*{ER5: Conceptual Clarity}
\begin{itemize}
    \item Game mechanics must clearly map to HPC concepts
    \item Visual design must distinguish shared vs. private data
    \item Terminology should align with parallel computing vocabulary when appropriate
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Functional Requirements}
\label{subsec:functional-requirements}

Functional requirements specify what the system must do:

\paragraph*{FR1: Card Management}
\begin{itemize}
    \item Generate configurable numbers of cards with unique values
    \item Shuffle cards randomly at game start
    \item Render cards with clear visual representation (number, state)
    \item Support dragging and dropping cards between containers
\end{itemize}

\paragraph*{FR2: Single-Player Mode}
\begin{itemize}
    \item Provide a single-player game mode representing sequential execution
    \item Display all cards in a scrollable container
    \item Provide work buffer zones for temporary storage
    \item Validate sorting order upon completion
    \item Display completion time and move count
\end{itemize}

\paragraph*{FR3: Multiplayer Mode}
\begin{itemize}
    \item Enable 2--4 players to connect via server-relayed networking
    \item Provide lobby for matchmaking and game configuration
    \item Display shared container visible to all players (OpenMP shared memory)
    \item Synchronize card movements across all clients
    \item Provide private buffers for each player (thread-local storage)
    \item Hide cards in other players' private buffers (thread-private data)
    \item Handle player disconnections gracefully
\end{itemize}

\paragraph*{FR4: User Interface}
\begin{itemize}
    \item Main menu with navigation to single-player and multiplayer modes
    \item Lobby interface for creating/joining games
    \item In-game UI with timer, move counter, player indicators
    \item Victory screen with performance summary
    \item Settings for theme, controls, and game parameters
\end{itemize}

\paragraph*{FR5: Feedback Systems}
\begin{itemize}
    \item Toast notifications for events (player joined, card moved, errors)
    \item Visual animations for card pickup, drop, invalid moves
    \item Sound effects for actions (optional, can be disabled)
    \item Confetti or celebration effects upon game completion
\end{itemize}

\paragraph*{FR6: Quality Attributes}
\begin{itemize}
    \item Target 60 FPS in modern web browsers
    \item Game initialization and card generation under 2 seconds
    \item Support up to 200 cards without significant performance degradation
    \item Intuitive interface requiring no tutorial for basic gameplay
    \item Responsive drag-and-drop with visual feedback
    \item Graceful handling of network disconnections
    \item Clean code structure with modular design
    \item Open-source license (MIT) for educational reuse
    \item No account creation or authentication required
\end{itemize}

%-----------------------------------------------------------------------
\section{Technology Selection}
\label{sec:technology-selection}

Technology choices significantly impact development efficiency, game performance, and future extensibility. This section justifies the selection of each major technology component.

%-----------------------------------------------------------------------
\subsection{Game Engine: Godot 4.x}
\label{subsec:godot-selection}

\paragraph*{Evaluation Criteria:}

Game engines were evaluated based on:
\begin{itemize}
    \item License and cost
    \item 2D rendering capabilities
    \item Web platform support (HTML5 export)
    \item Learning curve and documentation
    \item Community support and plugin ecosystem
    \item Multiplayer/networking support
    \item Performance in browsers
\end{itemize}

\paragraph*{Alternatives Considered:}
\par

\begin{table}[htbp]
    \centering
    \caption{Game engine comparison for HPC Sorting Game}
    \label{tab:engine-comparison}
    \begin{tabular}{@{}lcccc@{}}
        \toprule
        \textbf{Criterion} & \textbf{Unity} & \textbf{Unreal} & \textbf{Godot} & \textbf{Cocos2d} \\
        \midrule
        Free/Open Source   & Partial        & Partial         & Yes            & Yes              \\
        2D Performance     & Good           & Fair            & Excellent      & Excellent        \\
        Web Export         & Good           & Fair            & Excellent      & Good             \\
        Learning Curve     & Medium         & Steep           & Gentle         & Medium           \\
        Networking APIs    & Good           & Excellent       & Good           & Fair             \\
        Community Size     & Large          & Large           & Medium         & Small            \\
        Export Size        & Large          & Very Large      & Small          & Medium           \\
        \bottomrule
    \end{tabular}
\end{table}

\paragraph*{Decision Rationale:}

Godot Engine was selected because:

\begin{enumerate}
    \item \textbf{Cost}: Completely free and open-source (MIT license), no royalties, subscriptions, or hidden fees. Critical for educational projects with no budget.

    \item \textbf{2D Optimization}: Godot is specifically optimized for 2D games, unlike Unity and Unreal which prioritize 3D. This results in better performance and smaller export sizes.

    \item \textbf{Lightweight}: Web export builds are significantly smaller (10--20 MB) compared to Unity (50--100 MB) or Unreal (100+ MB), important for fast loading in browsers.

    \item \textbf{GDScript}: Python-like scripting language is accessible to students who may examine the source code. Lower barrier to entry than C\# (Unity) or C++ (Unreal).

    \item \textbf{Scene Architecture}: Godot's scene-based architecture promotes modular design and code reuse, aligning well with software engineering best practices.

    \item \textbf{Built-in Multiplayer}: High-level networking APIs available, though third-party frameworks (GDSync) and custom transport layers were needed for web browser compatibility.

    \item \textbf{Active Community}: Growing community with extensive tutorials, documentation, and plugins. Version 4.x introduced significant improvements over 3.x.

    \item \textbf{Ethical Alignment}: Open-source philosophy aligns with educational values and ensures long-term availability without corporate dependencies.
\end{enumerate}

\paragraph*{Trade-offs:}

Godot's limitations include:
\begin{itemize}
    \item Smaller community and fewer third-party assets compared to Unity
    \item Fewer commercial games as reference implementations
    \item Some plugins less mature than Unity Asset Store equivalents
    \item 3D capabilities lag behind Unity/Unreal (not relevant for this project)
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Programming Language: GDScript}
\label{subsec:gdscript-selection}

\paragraph*{Language Options in Godot:}

Godot supports three primary programming approaches:
\begin{enumerate}
    \item \textbf{GDScript}: Native scripting language, Python-like syntax
    \item \textbf{C\#}: .NET support via Mono runtime
    \item \textbf{C++}: Native modules via GDNative/GDExtension
\end{enumerate}

\paragraph*{Decision Rationale:}

GDScript was chosen because:

\begin{itemize}
    \item \textbf{Integration}: Tight integration with Godot Engine, optimized for game scripting
    \item \textbf{Simplicity}: Python-like syntax is readable and approachable for students
    \item \textbf{Rapid Development}: Dynamic typing and concise syntax accelerate prototyping
    \item \textbf{Documentation}: Most Godot tutorials and examples use GDScript
    \item \textbf{Performance}: Sufficient for 2D game logic; bottlenecks typically in rendering, not scripting
    \item \textbf{No Build Step}: Interpreted languageâ€”no compilation required for iteration
\end{itemize}

\paragraph*{Performance Considerations:}

GDScript is slower than C++ but acceptable for this use case because:
\begin{itemize}
    \item Card sorting logic is not computationally intensive
    \item Godot's rendering engine (written in C++) handles performance-critical operations
    \item Network latency dominates over local computation time
    \item Development speed more important than raw execution speed
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Multiplayer Framework: GDSync}
\label{subsec:gdsync-selection}

\paragraph*{Multiplayer Implementation Options:}

Three approaches were considered for multiplayer networking:

\begin{enumerate}
    \item \textbf{Raw Godot Networking}: Use built-in \texttt{ENetMultiplayerPeer} and RPC system
    \item \textbf{GDSync Framework}: Third-party addon providing high-level synchronization abstractions
    \item \textbf{Custom Protocol}: Build custom WebRTC integration from scratch
\end{enumerate}

\paragraph*{Decision Rationale:}

GDSync was selected because:

\begin{itemize}
    \item \textbf{Abstraction Level}: Provides higher-level abstractions than raw Godot networking, reducing boilerplate code
    \item \textbf{State Synchronization}: Built-in support for synchronizing node properties automatically
    \item \textbf{RPC Simplification}: Cleaner RPC syntax and management compared to Godot's built-in system
    \item \textbf{Active Development}: Maintained project with community support
    \item \textbf{Documentation}: Adequate documentation and examples for common use cases
    \item \textbf{Compatibility}: Works well with Godot 4.x and WebRTC connections
\end{itemize}

\paragraph*{Challenges Encountered:}

GDSync introduced some difficulties:

\begin{itemize}
    \item \textbf{Protected Mode Issue}: Default "protected" mode blocked RPC calls between peers, requiring workarounds (see Chapter~\ref{ch:problems})
    \item \textbf{Documentation Gaps}: Some features underdocumented or unclear
    \item \textbf{Debugging}: Opaque error messages complicated troubleshooting
    \item \textbf{Framework Overhead}: Additional layer of abstraction sometimes obscured underlying networking behavior
\end{itemize}

Despite these challenges, GDSync provided net benefits by significantly reducing the amount of low-level networking code required.

%-----------------------------------------------------------------------
\subsection{Networking Technology: HTTP/SSE Relay}
\label{subsec:http-sse-selection}

\paragraph*{Web Browser Constraints:}

Web browsers impose significant restrictions on networking that prevented use of traditional approaches:

\begin{itemize}
    \item \textbf{No UDP Access}: Browsers cannot open raw UDP sockets, eliminating ENet and similar protocols
    \item \textbf{WebRTC Complexity}: While browsers support WebRTC, GDSync's native WebRTC implementation does not function in browser-exported Godot games due to sandboxing
    \item \textbf{No LAN Discovery}: Browser security prevents local network peer discovery
\end{itemize}

\paragraph*{Solution: HTTP + Server-Sent Events (SSE)}

To overcome browser limitations, a custom relay server architecture was developed:

\begin{enumerate}
    \item \textbf{HTTP POST for Commands}: All game packets sent via standard HTTP POST requests
    \item \textbf{SSE for Real-time Events}: Server-Sent Events provide push notifications to clients
    \item \textbf{Server Relay}: All communication passes through the relay server rather than peer-to-peer
    \item \textbf{Star Topology}: Clients connect to server; host receives, processes, and broadcasts via server
\end{enumerate}

\paragraph*{Relay Server Implementation:}

The relay server (Python/aiohttp) provides:
\begin{itemize}
    \item \texttt{POST /api/lobby/connect} --- Client registration and peer ID assignment
    \item \texttt{POST /api/lobby/create} --- Create lobby with room code
    \item \texttt{POST /api/lobby/join} --- Join existing lobby by code
    \item \texttt{POST /api/lobby/broadcast} --- Send game packets to other peers
    \item \texttt{GET /api/lobby/events} --- SSE stream for receiving real-time events
\end{itemize}

\paragraph*{Trade-offs:}

This architecture has trade-offs compared to peer-to-peer approaches:
\begin{itemize}
    \item \textbf{Advantage}: Universal browser compatibility without plugins
    \item \textbf{Advantage}: Simplified connection establishment (no STUN/TURN configuration)
    \item \textbf{Trade-off}: Requires running relay server infrastructure
    \item \textbf{Trade-off}: Higher latency due to server hop (acceptable for turn-based card game)
\end{itemize}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.75\textwidth]{figures/diagrams/http-sse-sequence.png}
    \caption{HTTP/SSE relay message flow: connection, lobby creation, and gameplay synchronization}
    \label{fig:http-sse-sequence}
\end{figure}

%-----------------------------------------------------------------------
\subsection{Supporting Plugins and Tools}
\label{subsec:supporting-tools}

Several Godot plugins were integrated to enhance development:

\paragraph*{ToastParty:}
\begin{itemize}
    \item Purpose: Display non-intrusive notification messages
    \item Use: Player joined/left, card moved, errors, game events
    \item Benefit: Provides feedback without blocking gameplay
\end{itemize}

\paragraph*{Logger:}
\begin{itemize}
    \item Purpose: Enhanced debugging output with categorization
    \item Use: Development troubleshooting and performance analysis
    \item Benefit: Structured logging with filtering capabilities
\end{itemize}

\paragraph*{VarTree:}
\begin{itemize}
    \item Purpose: Runtime variable inspection and modification
    \item Use: Debugging game state during development
    \item Benefit: Observe and manipulate variables without recompiling
\end{itemize}

\paragraph*{Scene-Selector:}
\begin{itemize}
    \item Purpose: Quick scene navigation during development
    \item Use: Switch between game scenes without main menu navigation
    \item Benefit: Faster iteration during development
\end{itemize}

%-----------------------------------------------------------------------
\section{Game Design Methodology}
\label{sec:game-design}

%-----------------------------------------------------------------------
\subsection{Mapping HPC Concepts to Game Mechanics}
\label{subsec:concept-mapping}

The core challenge was translating abstract parallel computing concepts into tangible game mechanics. Table~\ref{tab:concept-mapping-methodology} shows the systematic mapping process:

\begin{table}[htbp]
    \centering
    \caption{Systematic mapping of HPC concepts to game mechanics}
    \label{tab:concept-mapping-methodology}
    \begin{tabular}{@{}p{3.5cm}p{4cm}p{5cm}@{}}
        \toprule
        \textbf{HPC Concept}   & \textbf{Real-World Analogy}        & \textbf{Game Mechanic}               \\
        \midrule
        Sequential Execution   & Single student working alone       & Single player in solo mode           \\
        Thread (OpenMP)        & Student with access to shared desk & Player in multiplayer mode           \\
        Shared Memory          & Desk visible to all students       & Shared card container                \\
        Thread-Local Storage   & Student's private notebook         & Player's private buffer zones        \\
        Parallel Execution     & Students work simultaneously       & Multiple players, no turn-taking     \\
        Synchronization        & Students coordinate access         & Shared container access patterns     \\
        Memory Access Overhead & Time to reach shared desk          & Network latency to shared data       \\
        Speedup                & Multiple students finish faster    & Timer comparison: solo vs. multi     \\
        Load Balancing         & Even distribution of work          & Fair work distribution among players \\
        \bottomrule
    \end{tabular}
\end{table}

\paragraph*{Design Validation:}

The pedagogical mapping was validated through:
\begin{itemize}
    \item Comparison with Professor D'Agostino's physical experiments
    \item Review by HPC instructors for conceptual accuracy
    \item Pilot testing with students familiar with parallel computing
    \item Iterative refinement based on feedback
\end{itemize}

%-----------------------------------------------------------------------
\subsection{User Experience Design}
\label{subsec:ux-design}

\paragraph*{Design Principles:}

\begin{enumerate}
    \item \textbf{Minimize Cognitive Load}: Simple, clear visuals; avoid information overload
    \item \textbf{Immediate Feedback}: Every action produces visual/audio response
    \item \textbf{Progressive Disclosure}: Show information when needed, hide complexity initially
    \item \textbf{Error Prevention}: Design interface to prevent common mistakes
    \item \textbf{Aesthetic Simplicity}: Clean, uncluttered design focuses attention on cards
\end{enumerate}

\paragraph*{Interaction Design:}

Card interactions were designed to work with both touch and mouse input:

\begin{itemize}
    \item \textbf{Click/Tap to Select}: Quick click or tap selects a card (alternative to drag)
    \item \textbf{Drag to Move}: Click-and-hold initiates drag, release drops card
    \item \textbf{Scroll}: Vertical scroll moves through card container
    \item \textbf{Visual Feedback}: Cards scale up when dragged, drop zones highlight
\end{itemize}

\paragraph*{Color Coding:}

Colors convey semantic meaning:

\begin{itemize}
    \item \textbf{Blue}: Normal cards, main container
    \item \textbf{Yellow}: Highlighted cards during drag
    \item \textbf{Gray}: Disabled/hidden cards (other players' buffers)
    \item \textbf{Purple}: Player-specific UI elements (buffers, indicators)
\end{itemize}

%-----------------------------------------------------------------------
% Note: Difficulty progression (Easy/Medium/Hard modes) was not implemented
% in the current version. This is discussed as future work in Chapter 8.

%-----------------------------------------------------------------------
\section{Evaluation Methodology}
\label{sec:evaluation-methodology}

\paragraph*{Evaluation Criteria:}

The game's success was evaluated across multiple dimensions:

\begin{enumerate}
    \item \textbf{Technical Performance}: Frame rate, memory usage, browser compatibility
    \item \textbf{Functional Completeness}: Implementation of all required features
    \item \textbf{Usability}: Ease of use, learnability, satisfaction
    \item \textbf{Educational Effectiveness}: Conceptual understanding, engagement, learning outcomes
\end{enumerate}

\paragraph*{Evaluation Methods:}

\subparagraph{Technical Benchmarking:}
\begin{itemize}
    \item Performance profiling using Godot's built-in tools
    \item Frame rate monitoring in target browsers
    \item Memory usage tracking during extended gameplay
\end{itemize}

\subparagraph{Usability Testing:}
\begin{itemize}
    \item Think-aloud protocols with test users
    \item Observation of first-time players
    \item Task completion rates and times
    \item System Usability Scale (SUS) questionnaire (if time permits)
\end{itemize}

\subparagraph{Educational Assessment:}
\begin{itemize}
    \item Pre/post-test knowledge assessments (if formal study conducted)
    \item Concept mapping to evaluate mental model formation
    \item Comparison with traditional teaching methods (if feasible)
    \item Qualitative feedback on perceived learning value
\end{itemize}

%-----------------------------------------------------------------------
\section{Development Tools and Environment}
\label{sec:dev-environment}

\paragraph*{Development Platform:}
\begin{itemize}
    \item \textbf{OS}: Windows 11 / Linux (Ubuntu 22.04)
    \item \textbf{IDE}: Visual Studio Code with GDScript extension
    \item \textbf{Engine}: Godot Engine 4.2.x
    \item \textbf{Version Control}: Git with GitHub repository
\end{itemize}

\paragraph*{Testing Environment:}
\begin{itemize}
    \item Primary: Chrome 120+ (Windows, macOS)
    \item Secondary: Firefox 120+ (Windows, Linux)
    \item Tertiary: Safari 17+ (macOS)
    \item Local development server for testing
\end{itemize}

\paragraph*{Build and Deployment:}
\begin{itemize}
    \item Web export (HTML5) built via Godot export templates
    \item Debug builds for development testing
    \item Release builds with optimizations for distribution
    \item Static file hosting for deployment
\end{itemize}

%-----------------------------------------------------------------------
\section{Summary}
\label{sec:methodology-summary}

This chapter described the comprehensive methodology employed to develop the HPC Sorting Serious Game:

\begin{itemize}
    \item \textbf{Research Approach}: Design Science Research framework with iterative development
    \item \textbf{Requirements}: Educational and functional requirements derived from learning objectives
    \item \textbf{Technology Selection}: Justified choices of Godot Engine, GDScript, GDSync, and HTTP/SSE relay architecture based on project needs
    \item \textbf{Game Design}: Systematic mapping of HPC concepts to game mechanics with UX design principles
    \item \textbf{Evaluation}: Multi-faceted evaluation approach combining technical, usability, and educational assessment
\end{itemize}

The next chapter presents the detailed system architecture resulting from these methodological decisions, including scene structure, component design, and multiplayer networking architecture.
