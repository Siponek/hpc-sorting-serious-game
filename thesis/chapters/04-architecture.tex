\chapter{System Design and Architecture}
\label{ch:architecture}

This chapter describes the comprehensive design and architecture of the HPC Sorting Serious Game. We present the system from multiple perspectives: high-level scene structure, core component design, multiplayer networking architecture, responsive UI considerations, and detailed data flow patterns.

%-----------------------------------------------------------------------
\section{Architectural Overview}
\label{sec:architectural-overview}

The game follows a component-based architecture typical of modern game engines, with clear separation of concerns between presentation, game logic, and networking layers. The architecture is designed to support both single-player (sequential execution) and multiplayer (OpenMP shared-memory simulation) modes with significant code reuse.

%-----------------------------------------------------------------------
\subsection{Design Principles}
\label{subsec:design-principles}

The architecture adheres to several key design principles:

\begin{enumerate}
    \item \textbf{Component-Based Design}: Game entities (cards, containers, buffers) are modular components that can be composed and reused.

    \item \textbf{Separation of Concerns}: Clear boundaries exist between UI presentation, game logic, and networking code.

    \item \textbf{Signal-Driven Communication}: Components communicate through Godot's signal system rather than tight coupling, improving maintainability.

    \item \textbf{Host-Authoritative Multiplayer}: One client (the host) serves as the authoritative source of truth to prevent cheating and simplify conflict resolution.

    \item \textbf{Responsive UI}: All interfaces are designed with responsive layouts that adapt to different screen sizes and support both touch and mouse input.

    \item \textbf{State Synchronization}: Clear patterns for synchronizing game state across multiple clients using the GDSync framework.
\end{enumerate}

%-----------------------------------------------------------------------
\subsection{System Layers}
\label{subsec:system-layers}

The system is organized into distinct logical layers:

\begin{description}
    \item[Presentation Layer] Handles all visual rendering, animations, user input (touch/mouse events), and UI components (menus, dialogs, toasts).

    \item[Game Logic Layer] Implements core game mechanics including card sorting validation, buffer management, timer control, and game state transitions.

    \item[Networking Layer] Manages relay server connections via HTTP/SSE, state synchronization through GDSync, lobby system for player matchmaking, and host election.

    \item[Framework Layer] Provides reusable utilities including scene management, settings persistence, theme management, logging, and debug tools.
\end{description}

%-----------------------------------------------------------------------
\section{Scene Structure}
\label{sec:scene-structure}

The game is organized into several distinct scenes, each representing a major screen or functional area. Godot's scene-based architecture naturally supports this modular organization.

%-----------------------------------------------------------------------
\subsection{Main Menu Scene}
\label{subsec:main-menu-scene}

The entry point of the application, providing navigation to all major features.

\paragraph*{Responsibilities:}
\begin{itemize}
    \item Display game title and branding
    \item Provide navigation buttons to single-player and multiplayer modes
    \item Access to settings (theme, audio, controls)
    \item Exit game or close browser tab
\end{itemize}

\paragraph*{Key Components:}
\begin{lstlisting}[language=Python, caption={Main menu scene structure (simplified)}]
MainMenuScene (Control)
|-- BackgroundPanel (Panel)
|-- TitleLabel (Label) "HPC Sorting Game"
|-- ButtonContainer (VBoxContainer)
|   |-- SinglePlayerButton (Button)
|   |-- MultiplayerButton (Button)
|   |-- SettingsButton (Button)
|   +-- QuitButton (Button)
+-- VersionLabel (Label)
\end{lstlisting}

%-----------------------------------------------------------------------
\subsection{Single-Player Game Scene}
\label{subsec:singleplayer-scene}

Implements the OpenMP simulation gameplay where players sort cards using private buffers.

\paragraph*{Responsibilities:}
\begin{itemize}
    \item Display all cards in a shared scrollable container
    \item Provide private buffer zones for local sorting
    \item Track game timer and move count
    \item Validate sorting order and detect completion
    \item Show victory screen with performance metrics
\end{itemize}

\paragraph*{Architecture:}

\begin{lstlisting}[language=Python, caption={Single-player scene hierarchy}]
SinglePlayerScene (Control)
|-- CardManager (Node) [Script: card_manager.gd]
|   |-- Timer (Timer)
|   +-- GameState (Dictionary)
|-- UI (Control)
|   |-- TopBar (HBoxContainer)
|   |   |-- TimerLabel (Label)
|   |   |-- MoveCountLabel (Label)
|   |   +-- BackButton (Button)
|   |-- CardScrollContainer (ScrollContainer)
|   |   +-- CardFlowContainer (HFlowContainer)
|   |       +-- [Card instances added dynamically]
|   +-- BufferContainer (VBoxContainer)
|       |-- Buffer1 (Panel)
|       |-- Buffer2 (Panel)
|       +-- Buffer3 (Panel)
+-- FinishGameWindow (PopupPanel)
    |-- CongratsLabel (Label)
    |-- TimeLabel (Label)
    |-- MovesLabel (Label)
    |-- RestartButton (Button)
    +-- MenuButton (Button)
\end{lstlisting}

\paragraph*{Key Design Decisions:}
\begin{itemize}
    \item \textbf{ScrollContainer for Cards}: Enables viewing large numbers of cards (50--200) on screens of various sizes by providing vertical scrolling.

    \item \textbf{FlowContainer Layout}: Automatically wraps cards to multiple rows based on screen width, providing responsive layout.

    \item \textbf{Separate Buffer Zones}: Physically distinct areas on screen to clearly represent private storage separate from shared container.

    \item \textbf{Single CardManager Node}: Centralized logic for game state, validation, and event coordination.
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Multiplayer Lobby Scene}
\label{subsec:lobby-scene}

Handles player matchmaking, room creation/joining, and connection management before gameplay.

\paragraph*{Responsibilities:}
\begin{itemize}
    \item Create or join game rooms via unique room codes
    \item Display list of connected players
    \item Handle host election and role assignment
    \item Configure game settings (number of cards, rules)
    \item Start game when all players are ready
    \item Manage connection status and timeouts
\end{itemize}

\paragraph*{Architecture:}

\begin{lstlisting}[language=Python, caption={Lobby scene structure}]
LobbyScene (Control)
|-- ConnectionManager (Node) [Script: connection_manager.gd]
|   |-- HTTPSSEConnection (Node)
|   |-- SignalingClient (WebSocketClient)
|   +-- PeerConnections (Dictionary)
|-- UI (Control)
|   |-- CreateRoomPanel (Panel)
|   |   |-- RoomCodeLabel (Label)
|   |   |-- CopyCodeButton (Button)
|   |   +-- StartGameButton (Button)
|   |-- JoinRoomPanel (Panel)
|   |   |-- RoomCodeInput (LineEdit)
|   |   +-- JoinButton (Button)
|   |-- PlayerListContainer (VBoxContainer)
|   |   +-- [PlayerCard instances]
|   +-- SettingsPanel (Panel)
|       |-- CardCountSlider (HSlider)
|       +-- ReadyCheckbox (CheckBox)
+-- ToastParty (Node) [Notifications]
\end{lstlisting}

\paragraph*{Connection Flow:}

\begin{enumerate}
    \item Host creates room → receives unique room code from signaling server
    \item Host shares room code with other players (via messaging, email, etc.)
    \item Other players enter room code and click Join
    \item Relay server facilitates peer discovery and connection via HTTP/SSE
    \item Direct peer-to-peer connections established (no server relay for game data)
    \item When all players ready, host initiates game scene transition
    \item GDSync framework ensures all clients load the multiplayer game scene synchronously
\end{enumerate}

%-----------------------------------------------------------------------
\subsection{Multiplayer Game Scene}
\label{subsec:multiplayer-scene}

Implements the OpenMP shared-memory simulation gameplay with collaborative sorting and private buffers.

\paragraph*{Responsibilities:}
\begin{itemize}
    \item Display shared container visible to all players (shared memory)
    \item Provide private buffer zones for each player (thread-local storage)
    \item Hide cards in other players' private buffers (thread-private data)
    \item Synchronize card movements across all clients
    \item Enable simultaneous access to shared container (parallel execution)
    \item Handle disconnections and reconnections gracefully
    \item Validate global sorting order
\end{itemize}

\paragraph*{Architecture:}

\begin{lstlisting}[language=Python, caption={Multiplayer scene hierarchy}]
MultiplayerScene (Control)
|-- MultiplayerCardManager (Node) [Script: multiplayer_card_manager.gd]
|   |-- Inherits: CardManager
|   |-- GDSyncNode (Node)
|   +-- NetworkState (Dictionary)
|       |-- cards_in_other_buffers: Dictionary
|       +-- pending_sync_operations: Array
|-- UI (Control)
|   |-- TopBar (HBoxContainer)
|   |   |-- PlayerIndicator (Label) "Player 2/4"
|   |   |-- TimerLabel (Label)
|   |   +-- ConnectionStatus (TextureRect)
|   |-- CardScrollContainer (ScrollContainer)
|   |   +-- [Cards visible to this player]
|   +-- BufferContainer (VBoxContainer)
|       +-- [Private buffers for this player]
+-- ConnectionManager (Node)
    +-- [Shared with lobby, manages peer connections]
\end{lstlisting}

\paragraph*{State Management:}

The multiplayer scene maintains several types of state:

\begin{description}
    \item[Local State] Information known only to this client (e.g., cards currently being dragged, UI state).

    \item[Private State] Information owned by this player but not visible to others (e.g., cards in this player's buffers).

    \item[Shared State] Information visible to all players (e.g., cards in the main container, timer, game completion status).

    \item[Authoritative State] The host's version of shared state, which is the source of truth for conflict resolution.
\end{description}

%-----------------------------------------------------------------------
\section{Core Components}
\label{sec:core-components}

%-----------------------------------------------------------------------
\subsection{Card Component}
\label{subsec:card-component}

The Card is the fundamental interactive element of the game, representing a single sortable item.

\paragraph*{Class Structure:}

\begin{lstlisting}[language=Python, caption={Card component class definition}]
class_name Card
extends Control

# Card properties
var card_value: int
var card_id: String  # Unique identifier (UUID)
var current_location: String  # "container", "buffer1", "buffer2", etc.
var owner_player_id: String  # For multiplayer

# Visual components
@onready var panel: Panel = $Panel
@onready var label: Label = $Panel/Label
@onready var animation_player: AnimationPlayer = $AnimationPlayer

# State
var is_being_dragged: bool = false
var original_position: Vector2
var original_slot_index: int

# Signals
signal card_picked_up(card: Card)
signal card_dropped(card: Card, target_container: Control)
signal card_clicked(card: Card)
\end{lstlisting}

\paragraph*{Key Responsibilities:}
\begin{itemize}
    \item Visual representation (panel background, number label, highlighting)
    \item Input handling (touch/mouse drag-and-drop)
    \item State tracking (location, ownership, drag state)
    \item Animations (pickup, drop, highlighting, shake for invalid moves)
    \item Signal emission for game logic integration
\end{itemize}

\paragraph*{Drag-and-Drop Implementation:}

\begin{lstlisting}[language=Python, caption={Card drag-and-drop logic}]
func _gui_input(event: InputEvent) -> void:
    if event is InputEventScreenTouch or event is InputEventMouseButton:
        if event.pressed:
            _on_pickup(event.position)
        else:
            _on_drop(event.position)
    elif event is InputEventScreenDrag or event is InputEventMouseMotion:
        if is_being_dragged:
            _on_drag(event.position)

func _on_pickup(position: Vector2) -> void:
    is_being_dragged = true
    original_position = global_position
    z_index = 100  # Bring to front
    scale = Vector2(1.1, 1.1)  # Visual feedback
    card_picked_up.emit(self)

func _on_drop(position: Vector2) -> void:
    is_being_dragged = false
    z_index = 0
    scale = Vector2(1.0, 1.0)
    
    var drop_target = _get_drop_target(position)
    if drop_target:
        card_dropped.emit(self, drop_target)
    else:
        # Return to original position
        _animate_return_to_original()
\end{lstlisting}

\paragraph*{Visual States:}
\begin{itemize}
    \item \textbf{Normal}: Default appearance
    \item \textbf{Highlighted}: When being dragged (scale 1.1x, slight shadow)
    \item \textbf{Disabled}: When in another player's buffer (semi-transparent, grayed out)
    \item \textbf{Invalid}: Shake animation when dropped in invalid location
    \item \textbf{Correct}: Green highlight when in correct sorted position
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Card Manager}
\label{subsec:card-manager}

The CardManager is the central controller for game logic in single-player mode, responsible for card lifecycle, validation, and game state transitions.

\paragraph*{Class Structure:}

\begin{lstlisting}[language=Python, caption={CardManager class structure}]
class_name CardManager
extends Node

# Configuration
var number_of_cards: int = 50
var card_scene: PackedScene = preload("res://scenes/CardScene/Card.tscn")

# Game state
var cards: Array[Card] = []
var game_started: bool = false
var start_time: float = 0.0
var move_count: int = 0

# References to UI containers
@onready var card_container: HFlowContainer
@onready var buffer_zones: Array[Panel] = []

# Signals
signal game_started()
signal game_finished(time: float, moves: int)
signal card_placed_in_container(card: Card, was_in_buffer: bool, slot: int)
signal card_entered_buffer(card: Card, buffer_index: int)
signal card_left_buffer(card: Card, buffer_index: int)
\end{lstlisting}

\paragraph*{Key Methods:}

\begin{lstlisting}[language=Python, caption={CardManager core methods}]
func initialize_game() -> void:
    """Generate and shuffle cards, start timer."""
    cards.clear()
    var values = range(1, number_of_cards + 1)
    values.shuffle()
    
    for value in values:
        var card = card_scene.instantiate()
        card.card_value = value
        card.card_id = UUID.generate()
        card.card_dropped.connect(_on_card_dropped)
        cards.append(card)
        card_container.add_child(card)
    
    start_time = Time.get_ticks_msec()
    game_started = true
    game_started.emit()

func check_sorting_order() -> bool:
    """Validate if cards in container are sorted."""
    var container_cards = _get_cards_in_container()
    if container_cards.size() != cards.size():
        return false  # Some cards still in buffers
    
    for i in range(container_cards.size() - 1):
        if container_cards[i].card_value > container_cards[i+1].card_value:
            return false  # Not sorted
    
    return true

func _on_card_dropped(card: Card, target_container: Control) -> void:
    """Handle card placement in container or buffer."""
    move_count += 1
    
    var was_in_buffer = card.current_location.begins_with("buffer")
    
    if target_container == card_container:
        var slot = _calculate_drop_slot(card.global_position)
        _move_card_to_slot(card, slot)
        card.current_location = "container"
        
        if was_in_buffer:
            card_left_buffer.emit(card, _get_buffer_index(card))
        
        card_placed_in_container.emit(card, was_in_buffer, slot)
        
        if check_sorting_order():
            _finish_game()
    
    elif target_container in buffer_zones:
        var buffer_index = buffer_zones.find(target_container)
        _move_card_to_buffer(card, buffer_index)
        card.current_location = "buffer%d" % buffer_index
        card_entered_buffer.emit(card, buffer_index)

func _finish_game() -> void:
    """Handle game completion."""
    var elapsed_time = (Time.get_ticks_msec() - start_time) / 1000.0
    game_finished.emit(elapsed_time, move_count)
    _show_finish_window(elapsed_time, move_count)
\end{lstlisting}

\paragraph*{Responsibilities Summary:}
\begin{itemize}
    \item Card generation and shuffling
    \item Timer management
    \item Move counting
    \item Drag-and-drop event coordination
    \item Buffer zone management
    \item Sorting validation
    \item Game completion detection
    \item Signal emission for UI updates
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Multiplayer Card Manager}
\label{subsec:multiplayer-card-manager}

The MultiplayerCardManager extends CardManager with synchronization logic for multiplayer gameplay.

\paragraph*{Architecture:}

\begin{lstlisting}[language=Python, caption={MultiplayerCardManager inheritance}]
class_name MultiplayerCardManager
extends CardManager

# Multiplayer-specific state
var is_host: bool = false
var my_player_id: String
var connected_players: Dictionary = {}  # player_id -> player_info
var cards_in_other_buffers: Dictionary = {}  # card_id -> player_id

# GDSync node reference
@onready var gdsync: Node

# Additional signals
signal sync_required(operation: String, data: Dictionary)
signal remote_card_moved(card_id: String, new_location: String)
\end{lstlisting}

\paragraph*{Host-Authoritative Model:}

The multiplayer architecture follows a host-authoritative pattern where the host maintains the canonical game state and clients request state changes:

\begin{enumerate}
    \item \textbf{Client Action}: Player drags a card and drops it
    \item \textbf{Local Update}: Client immediately updates local visuals for responsiveness
    \item \textbf{Broadcast to Host}: Client sends action to host via GDSync RPC
    \item \textbf{Host Validation}: Host validates the move (e.g., checks if card is available)
    \item \textbf{Host Broadcast}: If valid, host broadcasts confirmed state to all clients
    \item \textbf{Client Reconciliation}: Clients apply authoritative update, correcting any discrepancies
\end{enumerate}

\paragraph*{Synchronization Methods:}

\begin{lstlisting}[language=Python, caption={Key synchronization methods}]
@rpc("any_peer", "call_remote", "reliable")
func sync_card_moved(card_id: String, new_slot: int, player_id: String) -> void:
    """Synchronize card reordering in main container."""
    if not is_host:
        # Only host processes sync requests
        return
    
    var card = _get_card_by_id(card_id)
    if card:
        _move_card_to_slot(card, new_slot)
        # Broadcast to all clients
        rpc("apply_card_moved", card_id, new_slot)

@rpc("authority", "call_remote", "reliable")
func apply_card_moved(card_id: String, new_slot: int) -> void:
    """Apply card movement from authoritative host."""
    var card = _get_card_by_id(card_id)
    if card:
        _move_card_to_slot(card, new_slot)

@rpc("any_peer", "call_remote", "reliable")
func sync_card_entered_buffer(card_id: String, player_id: String, buffer_index: int) -> void:
    """Synchronize card moving to a player's private buffer."""
    if not is_host:
        return
    
    # Record which player has this card
    cards_in_other_buffers[card_id] = player_id
    
    # Broadcast to all clients to hide the card
    rpc("apply_card_entered_buffer", card_id, player_id, buffer_index)

@rpc("authority", "call_remote", "reliable")
func apply_card_entered_buffer(card_id: String, player_id: String, buffer_index: int) -> void:
    """Hide card that entered another player's buffer."""
    if player_id == my_player_id:
        return  # Owner still sees their own cards
    
    var card = _get_card_by_id(card_id)
    if card:
        card.visible = false
        card.set_process_input(false)  # Disable interaction

@rpc("any_peer", "call_remote", "reliable")
func sync_card_left_buffer(card_id: String, player_id: String) -> void:
    """Synchronize card leaving a player's buffer back to container."""
    if not is_host:
        return
    
    if card_id in cards_in_other_buffers:
        cards_in_other_buffers.erase(card_id)
    
    # Broadcast to make card visible again
    rpc("apply_card_left_buffer", card_id)

@rpc("authority", "call_remote", "reliable")
func apply_card_left_buffer(card_id: String) -> void:
    """Show card that returned from a buffer."""
    var card = _get_card_by_id(card_id)
    if card:
        card.visible = true
        card.set_process_input(true)

func sync_complete_game_state(target_peer_id: int) -> void:
    """Send full game state to newly connected player."""
    if not is_host:
        return
    
    var state = {
        "cards": _serialize_card_state(),
        "timer": get_elapsed_time(),
        "moves": move_count,
        "buffers": cards_in_other_buffers.duplicate()
    }
    
    rpc_id(target_peer_id, "apply_complete_game_state", state)
\end{lstlisting}

\paragraph*{Visibility Management:}

A critical aspect of the OpenMP simulation is maintaining correct visibility of cards to represent thread-private data:

\begin{itemize}
    \item \textbf{Cards in shared container}: Visible to all players (shared memory)
    \item \textbf{Cards in my private buffers}: Visible only to me (my thread-local storage)
    \item \textbf{Cards in other players' private buffers}: Hidden from view (other threads' private data)
    \item \textbf{Cards being moved}: Brief transition animation showing memory access
\end{itemize}

The \texttt{cards\_in\_other\_buffers} dictionary tracks which cards are currently private:

\begin{lstlisting}[language=Python, caption={Visibility tracking}]
var cards_in_other_buffers: Dictionary = {}
# Example state:
# {
#   "card_uuid_123": "player_2",
#   "card_uuid_456": "player_2",
#   "card_uuid_789": "player_3"
# }
\end{lstlisting}

%-----------------------------------------------------------------------
\subsection{Scroll Container and Layout}
\label{subsec:scroll-container}

Managing 50--200 cards on screen requires efficient layout and scrolling.

\paragraph*{Architecture:}

\begin{lstlisting}[language=Python, caption={Scrollable card container structure}]
CardScrollContainer (ScrollContainer)
|-- scroll_vertical_enabled = true
|-- scroll_horizontal_enabled = false
+-- CardFlowContainer (HFlowContainer)
    |-- alignment = ALIGNMENT_BEGIN
    |-- separation = 10
    +-- [Card instances]
\end{lstlisting}

\paragraph*{Layout Strategy:}

\begin{itemize}
    \item \textbf{HFlowContainer}: Automatically wraps cards to multiple rows based on available width
    \item \textbf{Responsive Card Size}: Cards scale based on screen width to fit approximately 4--6 per row
    \item \textbf{Vertical Scrolling Only}: Horizontal scrolling disabled for simpler interaction
    \item \textbf{Input-Optimized}: Large click/touch targets, smooth scroll physics
\end{itemize}

\paragraph*{Drop Target Detection:}

\begin{lstlisting}[language=Python, caption={Drop slot calculation}]
func _calculate_drop_slot(drop_position: Vector2) -> int:
    """Determine which slot a card should be dropped into."""
    var container_cards = card_container.get_children()
    
    # Convert global position to local container position
    var local_pos = card_container.to_local(drop_position)
    
    # Iterate through existing cards to find insertion point
    for i in range(container_cards.size()):
        var card = container_cards[i]
        var card_center = card.position + card.size / 2
        
        if local_pos.x < card_center.x:
            return i
    
    # Drop after all cards
    return container_cards.size()
\end{lstlisting}

%-----------------------------------------------------------------------
\section{Multiplayer Architecture}
\label{sec:multiplayer-architecture}

%-----------------------------------------------------------------------
\subsection{Network Topology}
\label{subsec:network-topology}

The game uses a \textbf{peer-to-peer (P2P) mesh network} topology with \textbf{host-authoritative state management}.

\paragraph*{Topology Diagram:}

\begin{verbatim}
    Player 1 (Host)
        |  \  \
        |   \  \___
        |    \      \
    Player 2  Player 3  Player 4
        |   ___/     /
        |  /    ____/
        | /    /
       \|/   |/
    Direct P2P Connections
\end{verbatim}

\paragraph*{Connection Characteristics:}
\begin{itemize}
    \item Each player connects through the relay server to communicate with other players
    \item No dedicated server required for gameplay (signaling server only used for initial connection)
    \item Low latency for small groups (2--4 players)
    \item Host election occurs if original host disconnects
\end{itemize}

%-----------------------------------------------------------------------
\subsection{State Synchronization Patterns}
\label{subsec:state-sync-patterns}

\paragraph*{Pattern 1: Optimistic Update with Confirmation}

Used for non-critical actions where responsiveness is important:

\begin{enumerate}
    \item Client performs action locally (e.g., moving card within own buffer)
    \item Client updates local visuals immediately
    \item Client sends action to host
    \item Host validates and broadcasts
    \item If host rejects, client receives correction and reverts
\end{enumerate}

\paragraph*{Pattern 2: Host Broadcast}

Used for host-initiated events:

\begin{enumerate}
    \item Host detects event (e.g., game timer expires, sorting complete)
    \item Host broadcasts event to all clients
    \item Clients apply event simultaneously
\end{enumerate}

%-----------------------------------------------------------------------
\subsection{GDSync Integration}
\label{subsec:gdsync-integration}

GDSync is a third-party multiplayer framework for Godot that provides high-level abstractions for state synchronization. For web browser compatibility, \textbf{a custom HTTP/SSE transport layer was implemented} to replace GDSync's native networking. The game primarily interacts with GDSync's RPC API, which then uses the custom transport layer for browser-based communication.

\paragraph*{Key Features Used:}
\begin{itemize}
    \item \textbf{RPC (Remote Procedure Calls)}: Call functions on remote peers
    \item \textbf{Node Replication}: Automatically sync node properties
    \item \textbf{Ownership System}: Track which peer owns which nodes
    \item \textbf{Authority Modes}: Specify who can call functions ("any\_peer", "authority")
    \item \textbf{Transport Abstraction}: Custom HTTP/SSE transport layer provides browser-compatible networking
\end{itemize}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.85\textwidth]{figures/diagrams/http-sse-architecture.png}
    \caption{HTTP/SSE relay architecture: star topology with centralized relay server}
    \label{fig:http-sse-architecture}
\end{figure}

\paragraph*{Configuration:}

\begin{lstlisting}[language=Python, caption={GDSync setup in MultiplayerCardManager}]
func _ready():
    super._ready()  # Call CardManager._ready()
    
    # Initialize GDSync
    gdsync = $GDSyncNode
    gdsync.set_multiplayer_authority(1)  # Host = peer ID 1
    
    # Register synchronized functions
    gdsync.register_rpc("sync_card_moved", 
                        Callable(self, "sync_card_moved"))
    gdsync.register_rpc("sync_card_entered_buffer", 
                        Callable(self, "sync_card_entered_buffer"))
    gdsync.register_rpc("sync_card_left_buffer", 
                        Callable(self, "sync_card_left_buffer"))
    
    # Connect to networking events
    multiplayer.peer_connected.connect(_on_peer_connected)
    multiplayer.peer_disconnected.connect(_on_peer_disconnected)
\end{lstlisting}

\paragraph*{RPC Call Patterns:}

\begin{lstlisting}[language=Python, caption={Using GDSync RPCs}]
# Pattern 1: Broadcast to all peers
func broadcast_card_moved(card_id: String, slot: int):
    rpc("sync_card_moved", card_id, slot, my_player_id)

# Pattern 2: Call specific peer
func send_to_host(data: Dictionary):
    rpc_id(1, "process_client_action", data)

# Pattern 3: Host broadcasts authoritative update
func host_broadcast_state():
    if is_host:
        rpc("apply_card_moved", card_id, new_slot)
\end{lstlisting}

%-----------------------------------------------------------------------
\subsection{Connection Management}
\label{subsec:connection-management}

\paragraph*{Lobby Phase:}
\begin{enumerate}
    \item Host creates room → signaling server assigns unique code
    \item Host shares code with players
    \item Players connect via relay server
    \item Each player establishes direct P2P connection with all others
    \item Host waits for all players ready
    \item Host triggers synchronized scene transition
\end{enumerate}

\paragraph*{Gameplay Phase:}
\begin{enumerate}
    \item Host initializes game state (shuffle cards, start timer)
    \item Host broadcasts initial state to all clients
    \item Clients apply initial state and begin gameplay
    \item Players send actions via RPC
    \item Host validates and broadcasts confirmations
    \item Game progresses until completion or disconnection
\end{enumerate}

\paragraph*{Disconnection Handling:}

\begin{lstlisting}[language=Python, caption={Handling player disconnections}]
func _on_peer_disconnected(peer_id: int):
    var player_name = connected_players[peer_id].name
    ToastParty.show_toast("%s disconnected" % player_name)
    
    connected_players.erase(peer_id)
    
    # If host disconnected, elect new host
    if peer_id == 1 and not is_host:
        _elect_new_host()
    
    # Release cards owned by disconnected player
    for card_id in cards_in_other_buffers.keys():
        if cards_in_other_buffers[card_id] == peer_id:
            cards_in_other_buffers.erase(card_id)
            _return_card_to_container(card_id)

func _elect_new_host():
    """Simple host election: lowest remaining peer ID becomes host."""
    var peer_ids = connected_players.keys()
    peer_ids.sort()
    var new_host_id = peer_ids[0]
    
    if multiplayer.get_unique_id() == new_host_id:
        is_host = true
        ToastParty.show_toast("You are now the host")
        gdsync.set_multiplayer_authority(new_host_id)
\end{lstlisting}

%-----------------------------------------------------------------------
\section{Data Flow Diagrams}
\label{sec:data-flow}

%-----------------------------------------------------------------------
\subsection{Single-Player Game Flow}
\label{subsec:singleplayer-flow}

\begin{verbatim}
User Input (Touch)
    |
    v
Card._gui_input()
    |
    v
Card.card_dropped.emit(card, target_container)
    |
    v
ScrollContainer._on_card_dropped() [signal forwarding]
    |
    v
CardManager._on_card_placed_in_container(card, was_in_buffer, slot)
    |
    +---> Update card position in container
    +---> Increment move counter
    +---> If was_in_buffer: emit card_left_buffer signal
    +---> emit card_placed_in_container signal
    |
    v
CardManager.check_sorting_order()
    |
    +---> If not sorted: continue gameplay
    |
    +---> If sorted:
          |
          v
          CardManager._finish_game()
              |
              +---> Stop timer
              +---> Calculate elapsed time
              +---> emit game_finished signal
              +---> Show finish window with confetti
\end{verbatim}

%-----------------------------------------------------------------------
\subsection{Multiplayer Card Movement Flow}
\label{subsec:multiplayer-flow}

\paragraph*{Scenario: Player 2 moves a card in the shared container}

\begin{verbatim}
Player 2 Client:
    User drags card to new position
        |
        v
    Card.card_dropped.emit()
        |
        v
    MultiplayerCardManager._on_card_placed_in_container()
        |
        +---> Update local visuals (immediate feedback)
        +---> Calculate new slot index
        |
        v
    RPC: sync_card_moved(card_id, new_slot, "player_2")
        |
        | [Network transmission]
        v

Host (Player 1):
    Receives sync_card_moved RPC
        |
        v
    Validate move (check card availability)
        |
        +---> If invalid: send rejection (not implemented yet)
        |
        +---> If valid:
              |
              v
              Apply move to host's game state
              |
              v
              RPC broadcast: apply_card_moved(card_id, new_slot)
                  |
                  | [Broadcast to all clients]
                  v

All Clients (including Player 2):
    Receive apply_card_moved RPC
        |
        v
    Apply authoritative card position
        |
        v
    Update UI: _move_card_to_slot(card, new_slot)
        |
        v
    Animation: smooth transition to new position
\end{verbatim}

%-----------------------------------------------------------------------
\subsection{Buffer Visibility Synchronization}
\label{subsec:buffer-visibility-flow}

\paragraph*{Scenario: Player 3 takes a card into their private buffer}

\begin{verbatim}
Player 3 Client:
    User drags card from container to buffer zone
        |
        v
    Card.card_dropped.emit(card, buffer_panel)
        |
        v
    MultiplayerCardManager._on_card_dropped()
        |
        +---> Determine target is buffer
        +---> Move card to buffer visually
        +---> Update card.current_location = "buffer1"
        |
        v
    RPC: sync_card_entered_buffer(card_id, "player_3", buffer_index)
        |
        | [Network transmission]
        v

Host (Player 1):
    Receives sync_card_entered_buffer RPC
        |
        v
    Record: cards_in_other_buffers[card_id] = "player_3"
        |
        v
    RPC broadcast: apply_card_entered_buffer(card_id, "player_3", buffer_index)
        |
        | [Broadcast to all clients]
        v

Player 1 & Player 2 Clients (others):
    Receive apply_card_entered_buffer RPC
        |
        v
    Check: Is this my card? (player_id == my_player_id)
        |
        +---> Yes (should not happen): do nothing
        |
        +---> No (card belongs to Player 3):
              |
              v
              Hide card: card.visible = false
              Disable interaction: card.set_process_input(false)

Player 3 Client (owner):
    Receive apply_card_entered_buffer RPC
        |
        v
    Check: Is this my card? YES
        |
        v
    Do nothing (card remains visible and interactive)
\end{verbatim}

\paragraph*{Result:}
\begin{itemize}
    \item Player 3 sees the card in their buffer and can interact with it
    \item Players 1, 2, and 4 do not see the card (simulating distributed memory)
    \item Card remains in game state but is hidden from other players' views
    \item When Player 3 returns the card to the container, \texttt{sync\_card\_left\_buffer} makes it visible again to everyone
\end{itemize}

%-----------------------------------------------------------------------
\section{Responsive UI/UX Design}
\label{sec:responsive-ui-ux}

%-----------------------------------------------------------------------
\subsection{Design Constraints}
\label{subsec:design-constraints}

Web platforms and varying screen sizes impose several constraints that significantly influenced design decisions:

\begin{itemize}
    \item \textbf{Screen Size}: 5--7 inch displays, approximately 1080x2400 pixels
    \item \textbf{Touch Input}: Fingers occlude content, require larger targets (minimum 44x44 dp)
    \item \textbf{Performance}: Variable GPU/CPU capabilities, battery constraints
    \item \textbf{Network}: Variable bandwidth, potential disconnections
    \item \textbf{Orientation}: Support both portrait and landscape
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Layout Strategies}
\label{subsec:layout-strategies}

\paragraph*{Card Display:}
\begin{itemize}
    \item Cards sized dynamically: \texttt{min(screen\_width / 6, 120px)}
    \item Approximately 4--6 cards per row on typical phones
    \item 10--20 rows visible depending on card count and screen size
    \item Vertical scrolling for navigation
\end{itemize}

\paragraph*{Buffer Zones:}
\begin{itemize}
    \item Fixed height panels at bottom of screen
    \item 2--3 buffers per player (configurable)
    \item Each buffer displays up to 10--15 cards in a horizontal flow
    \item Collapse/expand toggles to save screen space
\end{itemize}

\paragraph*{Top Bar:}
\begin{itemize}
    \item Fixed position header with timer, move count, player indicator
    \item Always visible during gameplay
    \item Minimal height to maximize card display area
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Touch Interaction Patterns}
\label{subsec:touch-interactions}

\paragraph*{Drag-and-Drop:}
\begin{itemize}
    \item Long-press to pick up card (500ms threshold prevents accidental drags)
    \item Visual feedback: card scales to 1.1x, drops shadow, follows finger
    \item Drag anywhere on screen
    \item Drop zones highlighted when card is near
    \item Snap-to-slot animation when dropped
    \item Shake animation if dropped in invalid location
\end{itemize}

\paragraph*{Scrolling vs. Dragging:}
\begin{itemize}
    \item ScrollContainer consumes vertical swipes
    \item Card drag consumes touch once long-press threshold reached
    \item Clear visual distinction: cards grow when draggable
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Visual Feedback Systems}
\label{subsec:visual-feedback}

\paragraph*{Toast Notifications:}
Brief non-intrusive messages for events:
\begin{itemize}
    \item ``Card entered buffer''
    \item ``Player 3 joined''
    \item ``Player disconnected''
    \item ``Game finished!''
\end{itemize}

\paragraph*{Animations:}
\begin{itemize}
    \item \textbf{Card Pickup}: Scale up, add shadow (200ms)
    \item \textbf{Card Drop}: Scale down, fade shadow (200ms)
    \item \textbf{Confetti}: Particle effect on game completion (3000ms)
\end{itemize}

\paragraph*{Color Coding:}
\begin{itemize}
    \item \textbf{Normal Cards}: Light blue background, black text
    \item \textbf{Highlighted Cards}: Yellow background (when dragging)
    \item \textbf{Hidden Cards}: 30\% opacity, gray (in other players' buffers)
    \item \textbf{Buffers}: Slightly darker background to distinguish from main container
\end{itemize}

%-----------------------------------------------------------------------
\section{Performance Considerations}
\label{sec:performance}

%-----------------------------------------------------------------------
\subsection{Optimization Strategies}
\label{subsec:optimizations}

\paragraph*{Rendering:}
\begin{itemize}
    \item Cards use simple Panel nodes (not full Control trees) to minimize draw calls
    \item Visibility culling: cards outside scroll view not rendered
    \item Animations use Tween for GPU-accelerated interpolation
    \item Limit particle effects (confetti) to 100--200 particles
\end{itemize}

\paragraph*{Networking:}
\begin{itemize}
    \item Aggregate multiple card movements before sending (debounce 100ms)
    \item Use ``reliable'' RPC only for critical state changes
    \item Use ``unreliable'' for non-critical updates (position interpolation)
    \item Compress state synchronization messages
\end{itemize}

\paragraph*{Memory:}
\begin{itemize}
    \item Reuse card instances instead of destroying/recreating
    \item Preload frequently used resources (card scene, textures)
    \item Clear large data structures when switching scenes
    \item Limit maximum cards to 200 to prevent memory issues
\end{itemize}

%-----------------------------------------------------------------------
\subsection{Scalability Limits}
\label{subsec:scalability-limits}

Based on testing and design constraints:

\begin{itemize}
    \item \textbf{Maximum Cards}: 200 (UI becomes difficult with more)
    \item \textbf{Maximum Players}: 4 (P2P mesh becomes inefficient beyond this)
    \item \textbf{Target Frame Rate}: 60 FPS in modern web browsers
    \item \textbf{Network Latency Tolerance}: Acceptable gameplay up to 200ms RTT
    \item \textbf{Minimum Screen Size}: 5-inch display (smaller makes cards too small)
\end{itemize}

%-----------------------------------------------------------------------
\section{Summary}
\label{sec:architecture-summary}

This chapter presented the comprehensive architecture of the HPC Sorting Serious Game, covering:

\begin{itemize}
    \item High-level system structure and design principles
    \item Scene organization and responsibilities
    \item Core component designs (Card, CardManager, MultiplayerCardManager)
    \item Multiplayer networking architecture with host-authoritative model
    \item GDSync framework integration for state synchronization
    \item Detailed data flow diagrams for single-player and multiplayer scenarios
    \item Responsive UI/UX design strategies and constraints
    \item Performance optimization considerations
\end{itemize}

The architecture balances educational effectiveness with technical feasibility, prioritizing clarity of HPC concept representation while maintaining acceptable performance across web browsers. The modular, component-based design allows for future extensions and modifications, fulfilling the extensibility objective outlined in Chapter~\ref{ch:introduction}.

The next chapter will detail the implementation of this architecture, including development tools, code organization, and specific technical challenges encountered during realization of this design.
