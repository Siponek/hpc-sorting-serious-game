\chapter{Problems and Challenges}
\label{ch:problems}

This chapter provides an honest and comprehensive analysis of the difficulties encountered during the development of the HPC Sorting Serious Game. Understanding these challenges and their solutions is valuable for future developers of educational multiplayer games and contributes to the body of knowledge in serious game development.

%----------------------------------------------------------------------------------------
\section{Overview}
\label{sec:problems-overview}

Development of a serious game involving real-time multiplayer synchronization on mobile devices presented numerous technical, design, and pedagogical challenges. These problems span multiple domains:

\begin{itemize}
    \item Technology selection and framework limitations
    \item Multiplayer state synchronization complexity
    \item Mobile UI/UX constraints
    \item Performance optimization requirements
    \item Documentation and community support gaps
    \item Testing and debugging difficulties
\end{itemize}

This chapter documents these challenges, the approaches taken to address them, and lessons learned that may benefit future projects.

%----------------------------------------------------------------------------------------
\section{Technology Selection Challenges}
\label{sec:technology-challenges}

%----------------------------------------------------------------------------------------
\subsection{Game Engine Trade-offs}
\label{subsec:engine-tradeoffs}

\paragraph{Challenge:}

While Godot Engine proved to be a good choice overall, several limitations became apparent during development:

\begin{itemize}
    \item \textbf{Smaller Ecosystem}: Fewer third-party plugins and assets compared to Unity, requiring custom solutions for some features
    \item \textbf{Documentation Gaps}: Godot 4.x was relatively new, with incomplete documentation for advanced networking scenarios
    \item \textbf{Mobile Export Issues}: Occasional problems with Android export templates and permission configurations
    \item \textbf{Plugin Compatibility}: Some Godot 3.x plugins not yet updated for 4.x
\end{itemize}

\paragraph{Impact:}

Development time increased due to the need to:
\begin{itemize}
    \item Build custom solutions rather than using existing plugins
    \item Troubleshoot export issues through trial and error
    \item Consult community forums for undocumented features
\end{itemize}

\paragraph{Mitigation:}

\begin{itemize}
    \item Active participation in Godot community (Discord, forums, GitHub)
    \item Contribution to documentation through issue reports and examples
    \item Development of reusable utility scripts for common tasks
    \item Careful version management and testing before engine updates
\end{itemize}

%----------------------------------------------------------------------------------------
\subsection{GDScript Performance Concerns}
\label{subsec:gdscript-performance}

\paragraph{Challenge:}

GDScript's interpreted nature raised concerns about performance with 50--200 cards requiring frequent position updates and collision detection.

\paragraph{Solution:}

Profiling revealed that:
\begin{itemize}
    \item GDScript performance was acceptable for game logic
    \item Bottlenecks were in rendering and physics, handled by Godot's C++ core
    \item Network latency dominated perceived lag, not scripting performance
\end{itemize}

Optimization strategies:
\begin{itemize}
    \item Minimize expensive operations in \texttt{\_process()} and \texttt{\_physics\_process()}
    \item Use object pooling to reduce instantiation overhead
    \item Batch updates where possible
    \item Profile early and often to identify actual bottlenecks
\end{itemize}

%----------------------------------------------------------------------------------------
\section{GDSync Framework Challenges}
\label{sec:gdsync-challenges}

The most significant technical challenges involved the GDSync framework, which, despite its high-level abstractions, presented several issues.

%----------------------------------------------------------------------------------------
\subsection{Protected Mode Blocking Issue}
\label{subsec:protected-mode-issue}

\paragraph{Challenge:}

GDSync's "protected mode" (default) prevented RPC calls from being executed between non-host peers. When Player A tried to call an RPC on Player B's node, the call would be silently dropped or blocked.

\paragraph{Error Manifestation:}

\begin{itemize}
    \item Card movement worked from host to clients but not between clients
    \item No error messages or warningsâ€”calls simply failed silently
    \item Debugging difficult due to lack of visibility into framework internals
\end{itemize}

\paragraph{Investigation Process:}

\begin{enumerate}
    \item Verified RPC syntax was correct according to documentation
    \item Added extensive logging to track RPC call flow
    \item Examined GDSync source code to understand permission system
    \item Tested with GDSync's example projects to compare behavior
    \item Posted issue on GDSync GitHub repository
\end{enumerate}

\paragraph{Solution:}

\begin{itemize}
    \item Disabled "protected mode" in GDSync configuration
    \item Implemented custom permission checks in application logic
    \item Contributed documentation improvements to GDSync project
    \item Shared findings with community to help future users
\end{itemize}

\paragraph{Lesson Learned:}

When using third-party frameworks:
\begin{itemize}
    \item Read source code, not just documentation
    \item Test framework features in isolation before integration
    \item Maintain good logging and diagnostic capabilities
    \item Engage with framework maintainers early when issues arise
\end{itemize}

%----------------------------------------------------------------------------------------
\subsection{Incomplete Documentation}
\label{subsec:gdsync-documentation}

\paragraph{Challenge:}

GDSync documentation covered basic use cases but lacked:
\begin{itemize}
    \item Examples of complex synchronization scenarios
    \item Explanation of internal mechanisms and limitations
    \item Best practices for performance optimization
    \item Troubleshooting guides for common problems
    \item Migration guide from vanilla Godot networking
\end{itemize}

\paragraph{Impact:}

\begin{itemize}
    \item Trial-and-error approach required for advanced features
    \item Difficulty distinguishing between usage errors and framework bugs
    \item Increased development time
    \item Frustration and consideration of framework replacement
\end{itemize}

\paragraph{Mitigation:}

\begin{itemize}
    \item Created internal documentation of discoveries and workarounds
    \item Maintained test project for isolating framework behavior
    \item Contributed examples and documentation improvements to upstream project
    \item Built abstraction layer to isolate GDSync-specific code
\end{itemize}

%----------------------------------------------------------------------------------------
\subsection{Debugging Multiplayer Issues}
\label{subsec:multiplayer-debugging}

\paragraph{Challenge:}

Debugging multiplayer code is inherently difficult:
\begin{itemize}
    \item Requires multiple devices or instances
    \item Race conditions and timing-dependent bugs
    \item Network variability complicates reproduction
    \item Limited visibility into remote client state
\end{itemize}

\paragraph{Solutions Implemented:}

\begin{enumerate}
    \item \textbf{Multi-Instance Testing}: Launched multiple Godot editor instances on the same machine
    \item \textbf{Network Logging}: Comprehensive logging of all network events with timestamps
    \item \textbf{State Dumps}: Ability to print full game state on command
    \item \textbf{Visual Indicators}: On-screen display of connection status, peer IDs, sync status
    \item \textbf{Replay System}: Recorded game events for post-mortem analysis
\end{enumerate}

%----------------------------------------------------------------------------------------
\section{Multiplayer Synchronization Challenges}
\label{sec:sync-challenges}

%----------------------------------------------------------------------------------------
\subsection{Card Order Synchronization}
\label{subsec:card-order-sync}

\paragraph{Challenge:}

Maintaining consistent card ordering across clients proved more complex than anticipated. Issues included:
\begin{itemize}
    \item Godot's scene tree ordering not guaranteed to match logical ordering
    \item Child node order not automatically synchronized
    \item Timing differences causing transient inconsistencies
\end{itemize}

\paragraph{Symptom:}

Cards appeared in different orders on different clients' screens, even though the underlying data was correct.

\paragraph{Solution:}

\begin{enumerate}
    \item Implemented explicit position indices for cards
    \item Synchronized card order separately from card positions
    \item Used z-index to control visual stacking order
    \item Periodic consistency checks and resynchronization
\end{enumerate}

\begin{lstlisting}[caption={Card order synchronization approach}]
# Each card has an explicit order index
var card_order_index: int

# Synchronize order explicitly
@GDSync.rpc(call_local=true)
func sync_card_order(card_id: int, new_index: int):
    var card = get_card_by_id(card_id)
    card.card_order_index = new_index
    resort_cards_by_index()
\end{lstlisting}

%----------------------------------------------------------------------------------------
\subsection{Timing and Race Conditions}
\label{subsec:timing-issues}

\paragraph{Challenge:}

Multiplayer systems are susceptible to race conditions:
\begin{itemize}
    \item Simultaneous card movements by different players
    \item Network messages arriving out of order
    \item Inconsistent state when players join mid-game
\end{itemize}

\paragraph{Examples:}

\begin{itemize}
    \item Two players drag the same card simultaneously
    \item Player joins lobby after game has started
    \item Card deleted on host but still referenced on client
\end{itemize}

\paragraph{Solutions:}

\begin{itemize}
    \item \textbf{Host Authority}: Only host can finalize state changes
    \item \textbf{Client Prediction with Rollback}: Show immediate feedback, then correct if host disagrees
    \item \textbf{State Snapshots}: New players receive full state snapshot on join
    \item \textbf{Defensive Programming}: Check object existence before operations
\end{itemize}

%----------------------------------------------------------------------------------------
\subsection{Different Client Views}
\label{subsec:client-views}

\paragraph{Challenge:}

In MPI mode, different players should see different cards (their private buffers should be hidden from others), but maintaining this selective visibility while synchronizing global state was complex.

\paragraph{Technical Issue:}

GDSync's node replication tries to keep all clients' scene trees identical, but selective visibility required different scene trees per client.

\paragraph{Solution:}

\begin{itemize}
    \item Replicate all cards to all clients (for consistency)
    \item Use visibility flags to hide inappropriate cards
    \item Implement client-side filtering based on ownership metadata
    \item Synchronize ownership and visibility separately from positions
\end{itemize}

%----------------------------------------------------------------------------------------
\section{Mobile UI/UX Challenges}
\label{sec:mobile-ux-challenges}

%----------------------------------------------------------------------------------------
\subsection{Displaying Many Cards on Small Screens}
\label{subsec:many-cards-small-screens}

\paragraph{Challenge:}

Displaying 50--200 cards on a 5--6 inch mobile screen presents significant layout challenges:
\begin{itemize}
    \item Cards must be large enough to read and tap
    \item All cards must be accessible without excessive scrolling
    \item Layout must work in both portrait and landscape orientations
\end{itemize}

\paragraph{Solutions Attempted:}

\begin{enumerate}
    \item \textbf{Grid Layout}: Cards arranged in a grid
          \begin{itemize}
              \item Pros: Space-efficient, familiar pattern
              \item Cons: Hard to see linear order, scrolling still required
          \end{itemize}

    \item \textbf{Scrollable Row}: Single row with horizontal scrolling
          \begin{itemize}
              \item Pros: Linear order visible, simple interaction
              \item Cons: Requires substantial scrolling with many cards
          \end{itemize}

    \item \textbf{Zoomable Canvas}: Pan and zoom to navigate cards
          \begin{itemize}
              \item Pros: Flexible navigation, can fit many cards
              \item Cons: Complex interaction, easy to get lost
          \end{itemize}

    \item \textbf{Hybrid Approach (Final Solution)}:
          \begin{itemize}
              \item Grid layout with intelligent sizing
              \item Vertical scrolling for overflow
              \item Zoom controls for adjusting card size
              \item Mini-map showing overall progress
          \end{itemize}
\end{enumerate}

%----------------------------------------------------------------------------------------
\subsection{Touch Interaction Precision}
\label{subsec:touch-precision}

\paragraph{Challenge:}

Touch input is less precise than mouse input:
\begin{itemize}
    \item Finger occludes card being dragged
    \item Difficulty selecting specific cards when densely packed
    \item Accidental touches and swipes
\end{itemize}

\paragraph{Solutions:}

\begin{itemize}
    \item \textbf{Offset Dragging}: Card rendered above finger with offset
    \item \textbf{Magnification}: Enlarge selected card for better visibility
    \item \textbf{Touch Feedback}: Visual and haptic feedback for touch events
    \item \textbf{Double-Tap Select}: Alternative to drag for card selection
    \item \textbf{Drop Zone Highlighting}: Clear indication of valid drop targets
\end{itemize}

%----------------------------------------------------------------------------------------
\subsection{Performance on Low-End Devices}
\label{subsec:lowend-performance}

\paragraph{Challenge:}

Not all students have flagship smartphones. The game needed to run acceptably on low-end and mid-range devices from 2018--2020.

\paragraph{Performance Constraints:}

\begin{itemize}
    \item Limited GPU power for rendering many cards
    \item Lower memory (2--4 GB RAM)
    \item Slower network hardware
    \item Battery life concerns
\end{itemize}

\paragraph{Optimization Strategies:}

\begin{itemize}
    \item Reduce draw calls through batching
    \item Use texture atlases to minimize state changes
    \item Implement level-of-detail (LOD) for distant cards
    \item Viewport culling to avoid rendering off-screen cards
    \item Adjustable quality settings (card detail, effects)
\end{itemize}

%----------------------------------------------------------------------------------------
\section{Testing Challenges}
\label{sec:testing-challenges}

%----------------------------------------------------------------------------------------
\subsection{Multiplayer Testing Complexity}
\label{subsec:multiplayer-testing}

\paragraph{Challenge:}

Testing multiplayer functionality requires:
\begin{itemize}
    \item Multiple devices or instances
    \item Coordination between test clients
    \item Reproduction of specific network conditions
    \item Testing edge cases (disconnections, late joins, etc.)
\end{itemize}

\paragraph{Approaches:}

\begin{enumerate}
    \item \textbf{Multi-Instance Desktop Testing}: Run multiple Godot instances on development machine
    \item \textbf{Physical Device Testing}: Test on actual Android phones
    \item \textbf{Automated Test Scenarios}: Scripts to simulate player actions
    \item \textbf{Network Simulation}: Tools to introduce latency and packet loss
\end{enumerate}

\paragraph{Limitations:}

\begin{itemize}
    \item Automated testing limited for interactive gameplay
    \item Difficult to reproduce exact timing of race conditions
    \item Real-world network conditions vary widely
\end{itemize}

%----------------------------------------------------------------------------------------
\subsection{Lack of Automated Testing}
\label{subsec:automated-testing}

\paragraph{Challenge:}

Godot's testing ecosystem is less mature than traditional software development frameworks:
\begin{itemize}
    \item No built-in unit testing framework
    \item GUI testing particularly difficult
    \item Networking code hard to test in isolation
\end{itemize}

\paragraph{Approach Taken:}

\begin{itemize}
    \item Manual testing with documented test cases
    \item Integration tests for critical paths
    \item Regression testing checklist before releases
    \item Community feedback as informal usability testing
\end{itemize}

\paragraph{Future Improvement:}

\begin{itemize}
    \item Integrate GUT (Godot Unit Test) framework
    \item Develop automated test suite for core logic
    \item Implement continuous integration pipeline
\end{itemize}

%----------------------------------------------------------------------------------------
\section{Educational Design Challenges}
\label{sec:educational-challenges}

%----------------------------------------------------------------------------------------
\subsection{Balancing Accuracy and Playability}
\label{subsec:accuracy-vs-playability}

\paragraph{Challenge:}

Educational games must balance pedagogical accuracy with engaging gameplay. Too much realism can reduce fun; too much simplification can create misconceptions.

\paragraph{Trade-offs Made:}

\begin{itemize}
    \item \textbf{Simplified Communication}: Actual MPI message passing is more complex than card exchanges
    \item \textbf{Abstracted Synchronization}: Real OpenMP requires explicit barriers and locks
    \item \textbf{Idealized Performance}: Network latency doesn't perfectly model HPC cluster interconnects
\end{itemize}

\paragraph{Mitigation:}

\begin{itemize}
    \item Clear framing: "This is a metaphor, not a simulation"
    \item Post-game discussions to connect game to real concepts
    \item Accompanying documentation explaining simplifications
    \item Progressive difficulty introducing more complexity
\end{itemize}

%----------------------------------------------------------------------------------------
\subsection{Assessment of Learning Effectiveness}
\label{subsec:learning-assessment}

\paragraph{Challenge:}

Demonstrating that the game actually improves learning outcomes requires formal educational research, including:
\begin{itemize}
    \item Pre/post-test measurements
    \item Control groups using traditional instruction
    \item Statistical analysis of results
    \item Long-term retention studies
\end{itemize}

\paragraph{Limitations:}

Within the scope of this thesis, full educational efficacy studies were not feasible due to:
\begin{itemize}
    \item Time constraints
    \item Need for institutional review board approval
    \item Difficulty recruiting sufficient participants
    \item Complexity of isolating game's effect from other factors
\end{itemize}

\paragraph{Future Work:}

Formal educational evaluation remains an important direction for future research, as discussed in Chapter~\ref{ch:conclusion}.

%----------------------------------------------------------------------------------------
\section{Lessons Learned}
\label{sec:lessons-learned}

%----------------------------------------------------------------------------------------
\subsection{Technical Lessons}
\label{subsec:technical-lessons}

\begin{enumerate}
    \item \textbf{Framework Evaluation}: Thoroughly evaluate third-party frameworks before committing; test advanced use cases early.

    \item \textbf{Abstraction Layers}: Isolate framework-specific code to facilitate future replacement if needed.

    \item \textbf{State Management}: Design clear state management patterns early; retrofitting is expensive.

    \item \textbf{Logging Infrastructure}: Comprehensive logging is essential for multiplayer debugging.

    \item \textbf{Performance Profiling}: Profile early and often; don't assume where bottlenecks are.
\end{enumerate}

%----------------------------------------------------------------------------------------
\subsection{Design Lessons}
\label{subsec:design-lessons}

\begin{enumerate}
    \item \textbf{User Testing}: Conduct user testing early; designer assumptions often wrong.

    \item \textbf{Mobile-First}: Design for mobile constraints from the start, not as an afterthought.

    \item \textbf{Simplicity}: Simpler interactions are better on mobile; complexity reduces usability.

    \item \textbf{Feedback}: Clear, immediate feedback is critical for learning and engagement.
\end{enumerate}

%----------------------------------------------------------------------------------------
\subsection{Process Lessons}
\label{subsec:process-lessons}

\begin{enumerate}
    \item \textbf{Iterative Development}: Iterative, incremental development surfaced issues early.

    \item \textbf{Version Control}: Frequent commits with clear messages saved time during debugging.

    \item \textbf{Documentation}: Documenting problems and solutions as they occurred proved invaluable.

    \item \textbf{Community Engagement}: Engaging with open-source communities provided solutions and support.
\end{enumerate}

%----------------------------------------------------------------------------------------
\section{Summary}
\label{sec:problems-summary}

This chapter documented the significant challenges encountered during development:

\begin{itemize}
    \item \textbf{Technology Challenges}: Engine trade-offs, framework limitations, and performance concerns
    \item \textbf{GDSync Issues}: Protected mode blocking, incomplete documentation, and debugging difficulty
    \item \textbf{Synchronization Complexity}: Card ordering, race conditions, and selective visibility
    \item \textbf{Mobile UI/UX}: Screen space constraints, touch precision, and device performance variability
    \item \textbf{Testing Difficulty}: Multiplayer testing complexity and lack of automated testing tools
    \item \textbf{Educational Design}: Balancing accuracy with playability and assessing learning effectiveness
\end{itemize}

Importantly, this chapter also presented solutions and lessons learned that will benefit future developers of similar educational multiplayer games. The next chapter evaluates the completed system and presents performance metrics and assessment results.
