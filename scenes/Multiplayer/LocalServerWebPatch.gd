extends Node

## LocalServerWebPatch.gd
## WebRTC-based replacement for GD-Sync's LocalServer.gd
## Uses PackRTC for signaling and WebRTC peer connections on web platform

## Custom signaling server URL. Set this before creating/joining lobbies.
## If empty, uses PackRTC's default (packcloud.himaji.xyz)
## Example: "http://192.168.1.100:3000" for local server
## For local testing, use localhost. For LAN play, use your IP (e.g., "http://192.168.1.14:3000")
var signaling_server_url: String = "http://localhost:3000"

## The room code generated by the signaling server (shared to let others join)
var current_room_code: String = ""

var GDSync
var connection_controller
var request_processor
var session_controller

# Lobby state (mirrors original LocalServer.gd)
var local_lobby_name: String = ""
var local_lobby_password: String = ""
var local_lobby_public: bool = false
var local_lobby_open: bool = true
var local_lobby_player_limit: int = 0

var local_lobby_data: Dictionary = {}
var local_lobby_tags: Dictionary = {}
var local_owner_cache: Dictionary = {}

var found_lobbies: Dictionary = {}

var peer_client_table: Dictionary = {}
var lobby_client_table: Dictionary = {}

# WebRTC specific
var rtc_session: PRSession = null
var is_host: bool = false
var _is_initialized: bool = false
@onready var logger = CustomLogger.get_logger(self)

# Client class (mirrors original)
class Client:
	extends RefCounted
	var valid: bool = false
	var client_id: int = -1
	var peer_id: int = -1
	var username: String
	var player_data: Dictionary = {}

	var requests_RUDP: Array = []
	var requests_UDP: Array = []
	var lobby_targets: Array = []

	func construct_lobby_targets(clients: Dictionary) -> void:
		lobby_targets = clients.values()
		lobby_targets.erase(self)

	func collect_player_data() -> Dictionary:
		var data: Dictionary = player_data.duplicate()
		data["ID"] = client_id
		data["Username"] = username
		return data


func _ready() -> void:
	GDSync = get_node("/root/GDSync")
	name = "LocalServer"
	connection_controller = GDSync._connection_controller
	request_processor = GDSync._request_processor
	session_controller = GDSync._session_controller

	# Configure PackRTC
	# Use server/client mode - host acts as server (peer_id=1), clients connect to it
	# This matches GDSync's expected semantics where host is the authority
	PackRTC.game_channel = "gdsync-hpc-sorting"
	PackRTC.use_mesh = false # Server/client mode, not mesh
	PackRTC.enable_debug = OS.has_feature("editor")

	# Apply custom signaling server URL if set
	_apply_signaling_url()

	# Set high process priority so we run BEFORE ConnectionController
	# This allows us to handle packet sending with proper set_target_peer() for WebRTC
	# before ConnectionController tries to send without it
	process_priority = -100

	set_process(false)
	logger.log_info(
		"LocalServerWebPatch initialized for web platform."
	)


func reset_multiplayer() -> void:
	logger.log_info("Resetting web multiplayer state.")

	# NOTE: We intentionally do NOT close the room on the signaling server here.
	# reset_multiplayer() is called by GD-Sync for various internal reasons
	# (initialization, cleanup, state transitions, etc.) and closing the room
	# here would break lobby discovery. The room should only be closed via
	# close_lobby() which is called when the host explicitly leaves.

	if rtc_session:
		rtc_session.queue_free()
		rtc_session = null

	set_process(false)
	found_lobbies.clear()
	clear_lobby_data()
	_is_initialized = false


## Explicitly close the lobby and remove it from the signaling server.
## Call this when the host intentionally leaves/closes the lobby.
func close_lobby() -> void:
	logger.log_info("Explicitly closing lobby.")

	if is_host and current_room_code != "":
		logger.log_info("Closing room on server: " + current_room_code)
		_close_room_on_server(current_room_code)

	reset_multiplayer()


func clear_lobby_data() -> void:
	logger.log_info("Clear lobby data.")
	local_lobby_name = ""
	local_lobby_password = ""
	current_room_code = ""

	local_lobby_data.clear()
	local_lobby_tags.clear()
	local_owner_cache.clear()
	peer_client_table.clear()
	lobby_client_table.clear()
	is_host = false


func start_local_peer() -> bool:
	logger.log_info(
		"Web platform: WebRTC mode - no UDP binding needed.",
		"[LocalServer-Web]"
	)
	# On web, we don't need to bind UDP ports
	# Return true to indicate successful initialization
	# Actual WebRTC connection happens when creating/joining lobby
	_is_initialized = true
	return true


func create_local_lobby(
	lobby_name: String,
	password: String = "",
	public: bool = true,
	player_limit: int = 0,
	tags: Dictionary = {},
	data: Dictionary = {}
) -> void:
	logger.log_info("Creating web lobby: " + lobby_name)

	# Validate lobby parameters
	if lobby_name.length() < 3:
		GDSync.lobby_creation_failed.emit.call_deferred(
			lobby_name, ENUMS.LOBBY_CREATION_ERROR.NAME_TOO_SHORT
		)
		return
	if lobby_name.length() > 32:
		GDSync.lobby_creation_failed.emit.call_deferred(
			lobby_name, ENUMS.LOBBY_CREATION_ERROR.NAME_TOO_LONG
		)
		return
	if password.length() > 16:
		GDSync.lobby_creation_failed.emit.call_deferred(
			lobby_name, ENUMS.LOBBY_CREATION_ERROR.PASSWORD_TOO_LONG
		)
		return
	if var_to_bytes(tags).size() > 2048:
		GDSync.lobby_creation_failed.emit.call_deferred(
			lobby_name, ENUMS.LOBBY_CREATION_ERROR.TAGS_TOO_LARGE
		)
		return
	if var_to_bytes(data).size() > 2048:
		GDSync.lobby_creation_failed.emit.call_deferred(
			lobby_name, ENUMS.LOBBY_CREATION_ERROR.DATA_TOO_LARGE
		)
		return

	# Use PackRTC to host
	PackRTC.game_channel = "gdsync-" + lobby_name.to_lower().replace(" ", "-")
	var session = await PackRTC.host()

	if session is PRSession:
		# Update room metadata on signaling server (PackRTC doesn't send lobby info)
		await _update_room_metadata(session.code, lobby_name, public, player_limit)
		rtc_session = session
		is_host = true

		# Store lobby state
		local_lobby_name = lobby_name
		local_lobby_password = password
		local_lobby_public = public
		local_lobby_player_limit = player_limit
		local_lobby_tags = tags
		local_lobby_data = data

		# Store the room code for sharing
		current_room_code = PackRTC.game_code

		# Add to found lobbies
		var lobby_dict: Dictionary = get_lobby_dictionary()
		lobby_dict["Code"] = current_room_code
		found_lobbies[local_lobby_name] = lobby_dict

		# Wait for WebRTC peer to be ready
		logger.log_info(
			"Waiting for WebRTC peer to be ready..."
		)
		await session.peer_ready

		# Set up multiplayer
		multiplayer.multiplayer_peer = session.rtc_peer
		# CRITICAL: Also set ConnectionController's client to use our WebRTC peer!
		# Otherwise ConnectionController._process() will see ENet client as DISCONNECTED
		# and call reset_multiplayer() immediately, wiping out our lobby state.
		connection_controller.client = session.rtc_peer

		# Connect peer signals
		session.rtc_peer.peer_connected.connect(_on_peer_connected)
		session.rtc_peer.peer_disconnected.connect(_on_peer_disconnected)

		# Set the host in connection controller so GDSync.is_host() works correctly
		var my_id = multiplayer.get_unique_id()
		connection_controller.set_host(my_id)
		connection_controller.in_local_lobby = true
		# CRITICAL: Set status to LOCAL_CONNECTION so is_local() returns true
		# This is needed for has_packets() to return true for SERVER/RELIABLE/UNRELIABLE channels
		connection_controller.status = ENUMS.CONNECTION_STATUS.LOCAL_CONNECTION

		# CRITICAL: Disable ConnectionController's _process so it doesn't consume our packets!
		# ConnectionController._process() calls client.get_packet() which consumes packets
		# before our LocalServerWebPatch._process() can see them.
		connection_controller.set_process(false)
		logger.log_info("Disabled ConnectionController._process() for host")

		# Add host to client tables (host doesn't trigger _on_peer_connected for itself)
		var host_client: Client = Client.new()
		host_client.peer_id = my_id
		host_client.client_id = my_id
		host_client.valid = true
		peer_client_table[my_id] = host_client
		lobby_client_table[my_id] = host_client

		set_process(true)
		logger.log_info(
			"Web lobby created. Code: " + current_room_code + ", Host ID: " + str(my_id)
		)
		# Emit with the room code so UI can display it for sharing
		GDSync.lobby_created.emit.call_deferred(current_room_code)
		# Emit client_joined for the host so they appear in the player list
		GDSync.client_joined.emit.call_deferred(my_id)
	else:
		logger.log_error(
			"Failed to create web lobby: " + str(session)
		)
		GDSync.lobby_creation_failed.emit.call_deferred(
			lobby_name, ENUMS.LOBBY_CREATION_ERROR.LOCAL_PORT_ERROR
		)


## Track if we need to send join request once connected
var _pending_join_lobby_name: String = ""
var _pending_join_password: String = ""
var _waiting_for_host_data_channel: bool = false

func join_lobby(lobby_name: String, password: String) -> void:
	# For web platform, lobby_name should be the room code (e.g., "AHLW")
	# generated by the signaling server when the host created the lobby
	var code = lobby_name.to_upper().strip_edges()
	logger.log_info("Joining web lobby with code: " + code)

	# Use PackRTC to join
	var session = await PackRTC.join(code)

	if session is PRSession:
		rtc_session = session
		is_host = false
		local_lobby_name = lobby_name
		local_lobby_password = password

		# Store join info - we'll send the actual join request once peer connects
		_pending_join_lobby_name = lobby_name
		_pending_join_password = password

		# Wait for WebRTC peer to be ready (signaling initiated)
		# NOTE: rtc_peer doesn't exist until peer_ready is emitted
		logger.log_info("Waiting for WebRTC peer to be ready...")
		await session.peer_ready
		logger.log_info("peer_ready signal received!")

		# Connect peer signals right after rtc_peer is created
		session.rtc_peer.peer_connected.connect(_on_peer_connected)
		session.rtc_peer.peer_disconnected.connect(_on_peer_disconnected)

		# Set up multiplayer
		multiplayer.multiplayer_peer = session.rtc_peer
		# CRITICAL: Also set ConnectionController's client to use our WebRTC peer!
		# Otherwise ConnectionController._process() will see ENet client as DISCONNECTED
		# and call reset_multiplayer() immediately, wiping out our lobby state.
		# NOTE: We handle packet sending in LocalServerWebPatch._process() with proper
		# set_target_peer(1) calls since ConnectionController doesn't do this for WebRTC.
		connection_controller.client = session.rtc_peer

		# For WebRTC, the host is always peer ID 1 (the one who created the session)
		connection_controller.set_host(1)
		connection_controller.in_local_lobby = true
		# CRITICAL: Set status to LOCAL_CONNECTION so is_local() returns true
		# This is needed for has_packets() to return true for SERVER/RELIABLE/UNRELIABLE channels
		connection_controller.status = ENUMS.CONNECTION_STATUS.LOCAL_CONNECTION

		# CRITICAL: Disable ConnectionController's _process so it doesn't interfere with our packet handling!
		# We handle all packet sending/receiving in LocalServerWebPatch._process()
		connection_controller.set_process(false)
		logger.log_info("Disabled ConnectionController._process() for client")

		set_process(true)

		var my_id = multiplayer.get_unique_id()
		logger.log_info("Joined web lobby (signaling complete). My ID: " + str(my_id) + ", Host ID: 1")

		# Check if the host peer is already connected (signal may have fired before we connected)
		var connection_status = session.rtc_peer.get_connection_status()
		var already_connected_peers = session.peers if session.peers else []
		var has_host_peer = session.rtc_peer.has_peer(1)
		logger.log_info("Connection status: " + str(connection_status) + ", Already known peers: " + str(already_connected_peers) + ", has_peer(1): " + str(has_host_peer))

		# Debug: Get the peer dictionary to see connection state
		if has_host_peer:
			var peer_dict = session.rtc_peer.get_peer(1)
			logger.log_info("Peer 1 info: " + str(peer_dict))

		# If host is already in the peers list, manually trigger the join flow
		if 1 in already_connected_peers and _pending_join_lobby_name != "":
			logger.log_info("Host already in peers list! Manually triggering join flow...")
			_on_peer_connected(1)
		elif has_host_peer and _pending_join_lobby_name != "":
			# has_peer returns true but peer wasn't in session.peers - check data channel state
			logger.log_info("Host peer exists via has_peer(1). Checking data channel state...")
			# We need to wait for data channel to be open. Start polling in _process
			_waiting_for_host_data_channel = true

		# NOTE: If host is not yet connected, _on_peer_connected will be called when it connects
	else:
		logger.log_error(
			"Failed to join web lobby: " + str(session)
		)
		GDSync.lobby_join_failed.emit.call_deferred(
			lobby_name, ENUMS.LOBBY_JOIN_ERROR.LOBBY_DOES_NOT_EXIST
		)


func get_public_lobbies() -> void:
	# Fetch lobbies from signaling server
	if signaling_server_url != "":
		_fetch_lobbies_from_server()
	else:
		# Fallback to locally known lobbies
		var lobbies: Array = []
		for lobby_data in found_lobbies.values():
			if lobby_data.get("Public", false):
				lobbies.append(lobby_data)
		logger.log_info(
			"Returning " + str(lobbies.size()) + " known lobbies.",
			"[LocalServer-Web]"
		)
		GDSync.lobbies_received.emit.call_deferred(lobbies)


func _fetch_lobbies_from_server() -> void:
	var http = HTTPRequest.new()
	add_child(http)
	http.request_completed.connect(_on_lobbies_request_completed.bind(http))
	var url = signaling_server_url + "/lobbies"
	var error = http.request(url)
	if error != OK:
		logger.log_error("Failed to request lobbies: " + str(error))
		http.queue_free()
		GDSync.lobbies_received.emit.call_deferred([])


func _on_lobbies_request_completed(result: int, response_code: int, _headers: PackedStringArray, body: PackedByteArray, http: HTTPRequest) -> void:
	http.queue_free()
	if result != HTTPRequest.RESULT_SUCCESS or response_code != 200:
		logger.log_error("Lobbies request failed: " + str(response_code))
		GDSync.lobbies_received.emit.call_deferred([])
		return

	var json = JSON.parse_string(body.get_string_from_utf8())
	if json == null or not json.has("lobbies"):
		logger.log_error("Invalid lobbies response")
		GDSync.lobbies_received.emit.call_deferred([])
		return

	var lobbies: Array = json.get("lobbies", [])
	logger.log_info("Fetched " + str(lobbies.size()) + " lobbies from server.")

	# Update local cache
	for lobby in lobbies:
		var name = lobby.get("Name", "")
		if name != "":
			found_lobbies[name] = lobby

	GDSync.lobbies_received.emit.call_deferred(lobbies)


func get_public_lobby(lobby_name: String) -> void:
	for lobby_data in found_lobbies.values():
		if (
			lobby_data.get("Public", false)
			and lobby_data.get("Name", "") == lobby_name
		):
			GDSync.lobby_received.emit.call_deferred(lobby_data)
			return

	GDSync.lobby_received.emit.call_deferred({})


func is_local_server() -> bool:
	return local_lobby_name != "" and is_host


func _on_peer_connected(id: int) -> void:
	logger.log_info("WebRTC peer connected: " + str(id) + ", is_host: " + str(is_host))

	# Debug: Log peer info immediately on connection
	if rtc_session and rtc_session.rtc_peer:
		var peer = rtc_session.rtc_peer
		var peer_info = peer.get_peer(id)
		if peer_info:
			logger.log_info("Peer " + str(id) + " connection details: " + str(peer_info))
			var channels = peer_info.get("channels", [])
			logger.log_info("Peer " + str(id) + " has " + str(channels.size()) + " channels")
			for i in range(channels.size()):
				var ch = channels[i]
				if ch:
					logger.log_info("  Channel " + str(i) + ": ready_state=" + str(ch.get_ready_state()) + ", label=" + ch.get_label())

	var client: Client = Client.new()
	client.peer_id = id
	client.client_id = id
	client.valid = true
	peer_client_table[id] = client
	lobby_client_table[id] = client

	# Rebuild lobby targets for all clients
	for client_id in lobby_client_table:
		lobby_client_table[client_id].construct_lobby_targets(
			lobby_client_table
		)

	# Update player count on signaling server (host only)
	if is_host and current_room_code != "":
		_update_player_count_on_server()

	# If we're a client and just connected to the host (peer 1), send pending GDSync join request
	if not is_host and id == 1 and _pending_join_lobby_name != "":
		logger.log_info("Connected to host! Sending GDSync join protocol messages...")
		# Clear waiting flag to prevent duplicate join flow from _process()
		_waiting_for_host_data_channel = false
		# Send client ID first
		request_processor.send_client_id()
		# Broadcast player data
		session_controller.broadcast_player_data()
		# Send join lobby request
		request_processor.create_join_lobby_request(_pending_join_lobby_name, _pending_join_password)
		# Clear pending state
		_pending_join_lobby_name = ""
		_pending_join_password = ""

		# CRITICAL: Send packets IMMEDIATELY instead of waiting for _process()
		# ConnectionController._process() runs and consumes packets before our _process() despite process_priority
		# So we must send the packets right here, right now.
		_send_client_packets_immediately()

	# Emit client joined
	GDSync.client_joined.emit.call_deferred(id)


func _on_peer_disconnected(id: int) -> void:
	logger.log_info(
		"WebRTC peer disconnected: " + str(id)
	)

	if lobby_client_table.has(id):
		lobby_client_table.erase(id)
	if peer_client_table.has(id):
		peer_client_table.erase(id)

	# Rebuild lobby targets
	for client_id in lobby_client_table:
		lobby_client_table[client_id].construct_lobby_targets(
			lobby_client_table
		)

	# Update player count on signaling server (host only)
	if is_host and current_room_code != "":
		_update_player_count_on_server()

	# Emit client left
	GDSync.client_left.emit.call_deferred(id)


## Send all queued client packets immediately to the host.
## This is called from _on_peer_connected() because we can't rely on _process()
## - ConnectionController._process() consumes packets before our _process() runs.
func _send_client_packets_immediately() -> void:
	if is_host or not rtc_session or not rtc_session.rtc_peer:
		return

	var peer = rtc_session.rtc_peer

	# Check what packets are available
	var has_setup = request_processor.has_packets(ENUMS.PACKET_CHANNEL.SETUP)
	var has_server = request_processor.has_packets(ENUMS.PACKET_CHANNEL.SERVER)
	var has_reliable = request_processor.has_packets(ENUMS.PACKET_CHANNEL.RELIABLE)
	var has_unreliable = request_processor.has_packets(ENUMS.PACKET_CHANNEL.UNRELIABLE)

	logger.log_info("Sending packets immediately - SETUP: " + str(has_setup) + ", SERVER: " + str(has_server) + ", RELIABLE: " + str(has_reliable) + ", UNRELIABLE: " + str(has_unreliable))

	# Debug: Check peer connection state
	var conn_status = peer.get_connection_status()
	var has_peer_1 = peer.has_peer(1)
	logger.log_info("Peer state before sending - connection_status: " + str(conn_status) + ", has_peer(1): " + str(has_peer_1))

	if conn_status != MultiplayerPeer.CONNECTION_CONNECTED:
		logger.log_warning("Cannot send packets - not connected! Status: " + str(conn_status))
		return

	if not has_peer_1:
		logger.log_warning("Cannot send packets - host peer (1) not found!")
		return

	# All client packets go to host (peer 1)
	peer.set_target_peer(1)

	if has_setup:
		var packet_data = request_processor.package_requests(ENUMS.PACKET_CHANNEL.SETUP)
		logger.log_info("CLIENT sending SETUP packet to host (immediate), size: " + str(packet_data.size()))
		peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_RELIABLE
		var err = peer.put_packet(packet_data)
		logger.log_info("SETUP put_packet result: " + str(err))
	if has_server:
		var packet_data = request_processor.package_requests(ENUMS.PACKET_CHANNEL.SERVER)
		logger.log_info("CLIENT sending SERVER packet to host (immediate), size: " + str(packet_data.size()) + ", first 20 bytes: " + str(packet_data.slice(0, min(20, packet_data.size()))))

		# Log channel state BEFORE sending
		var peer_info_before = peer.get_peer(1)
		if peer_info_before:
			var channels_before = peer_info_before.get("channels", [])
			if channels_before.size() > 0 and channels_before[0]:
				logger.log_info("Channel 0 BEFORE send: buffered=" + str(channels_before[0].get_buffered_amount()))

		peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_RELIABLE
		var err = peer.put_packet(packet_data)
		logger.log_info("SERVER put_packet result: " + str(err) + " (0=OK)")

		# Debug: Also log channel states for peer 1 AFTER sending
		var peer_info = peer.get_peer(1)
		if peer_info:
			logger.log_info("Peer 1 info after send: connected=" + str(peer_info.get("connected", "?")) + ", channels=" + str(peer_info.get("channels", []).size()))
			# Check individual channel states
			var channels = peer_info.get("channels", [])
			for i in range(channels.size()):
				var ch = channels[i]
				if ch:
					var state = ch.get_ready_state()
					var label = ch.get_label()
					var buffered = ch.get_buffered_amount()
					logger.log_info("  Channel " + str(i) + " (" + label + "): ready_state=" + str(state) + ", buffered=" + str(buffered) + " AFTER send")
	if has_reliable:
		var packet_data = request_processor.package_requests(ENUMS.PACKET_CHANNEL.RELIABLE)
		logger.log_info("CLIENT sending RELIABLE packet to host (immediate), size: " + str(packet_data.size()))
		peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_RELIABLE
		var err = peer.put_packet(packet_data)
		logger.log_info("RELIABLE put_packet result: " + str(err))
	if has_unreliable:
		var packet_data = request_processor.package_requests(ENUMS.PACKET_CHANNEL.UNRELIABLE)
		logger.log_info("CLIENT sending UNRELIABLE packet to host (immediate), size: " + str(packet_data.size()))
		peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_UNRELIABLE_ORDERED
		var err = peer.put_packet(packet_data)
		logger.log_info("UNRELIABLE put_packet result: " + str(err))


## Trigger the join flow when data channel becomes ready (alternative path to _on_peer_connected)
func _trigger_join_flow() -> void:
	if is_host:
		return

	# Add host to our client tables if not already present
	if not peer_client_table.has(1):
		var client: Client = Client.new()
		client.peer_id = 1
		client.client_id = 1
		client.valid = true
		peer_client_table[1] = client
		lobby_client_table[1] = client

	logger.log_info("Triggering join flow - sending GDSync join protocol messages...")
	# Send client ID first
	request_processor.send_client_id()
	# Broadcast player data
	session_controller.broadcast_player_data()
	# Send join lobby request
	request_processor.create_join_lobby_request(local_lobby_name, local_lobby_password)

	# Send packets immediately
	_send_client_packets_immediately()

	# Emit client joined for host
	GDSync.client_joined.emit.call_deferred(1)


var _debug_log_counter: int = 0

func _process(_delta: float) -> void:
	if not rtc_session or not rtc_session.rtc_peer:
		return

	var peer = rtc_session.rtc_peer
	var status = peer.get_connection_status()

	# Log connection status periodically for debugging (every 10 seconds)
	_debug_log_counter += 1
	if _debug_log_counter % 600 == 1: # Log every ~10 seconds at 60fps
		var status_name = "UNKNOWN"
		match status:
			MultiplayerPeer.CONNECTION_DISCONNECTED: status_name = "DISCONNECTED"
			MultiplayerPeer.CONNECTION_CONNECTING: status_name = "CONNECTING"
			MultiplayerPeer.CONNECTION_CONNECTED: status_name = "CONNECTED"
		var has_peer_1_str = str(peer.has_peer(1)) if not is_host else "N/A"
		logger.log_info("WebRTC status: " + status_name + ", is_host: " + str(is_host) + ", peers: " + str(peer_client_table.keys()) + ", has_peer(1): " + has_peer_1_str)

	# Check if we're waiting for host data channel to be ready (client only)
	if _waiting_for_host_data_channel and not is_host:
		if peer.has_peer(1):
			var peer_info = peer.get_peer(1)
			# peer_info is a Dictionary with "connection" and "channels" keys
			# Check if data channel is ready by trying to see the connection state
			if peer_info and peer_info.has("connection"):
				var connection: WebRTCPeerConnection = peer_info["connection"]
				var conn_state = connection.get_connection_state()
				# WebRTCPeerConnection.STATE_CONNECTED = 2
				if conn_state == WebRTCPeerConnection.STATE_CONNECTED:
					logger.log_info("Host data channel is ready! Triggering join flow...")
					_waiting_for_host_data_channel = false
					# Trigger the full join flow which will send packets immediately
					_trigger_join_flow()

	match (status):
		MultiplayerPeer.CONNECTION_DISCONNECTED:
			logger.log_info("WebRTC peer lost connection.")
			connection_controller.reset_multiplayer()
		MultiplayerPeer.CONNECTION_CONNECTING:
			peer.poll()
		MultiplayerPeer.CONNECTION_CONNECTED:
			peer.poll()

			# Immediately check for packets after poll (for both host and client)
			var immediate_pkt_count = peer.get_available_packet_count()
			if immediate_pkt_count > 0:
				logger.log_info("POLL: " + str(immediate_pkt_count) + " packets available after poll, is_host=" + str(is_host))

			if is_host:
				# Debug: Log peer status and packet count periodically
				if _debug_log_counter % 60 == 1: # Every ~1 second
					var peer_list = []
					for pid in peer_client_table.keys():
						if pid != 1: # Skip self
							var has_p = peer.has_peer(pid)
							peer_list.append(str(pid) + "(has=" + str(has_p) + ")")
					var pkt_count = peer.get_available_packet_count()
					if peer_list.size() > 0:
						logger.log_info("HOST peers: " + ", ".join(peer_list) + ", packets_available: " + str(pkt_count))

					# Debug: Check the peer info for each connected peer
					for pid in peer_client_table.keys():
						if pid != 1 and peer.has_peer(pid):
							var peer_info = peer.get_peer(pid)
							if peer_info:
								logger.log_info("HOST peer " + str(pid) + " info: connected=" + str(peer_info.get("connected", "?")) + ", channels=" + str(peer_info.get("channels", []).size()))
								# Check individual channel states on host side
								var channels = peer_info.get("channels", [])
								for i in range(channels.size()):
									var ch = channels[i]
									if ch:
										var state = ch.get_ready_state()
										var label = ch.get_label()
										logger.log_info("  HOST Channel " + str(i) + " (" + label + "): ready_state=" + str(state))

				# HOST: Send queued requests to clients
				for peer_id in peer_client_table:
					var client: Client = peer_client_table[peer_id]
					if client.requests_RUDP.size() > 0:
						logger.log_info("HOST sending RUDP to peer " + str(peer_id) + ", count: " + str(client.requests_RUDP.size()))
						peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_RELIABLE
						peer.set_target_peer(client.peer_id)
						peer.put_packet(var_to_bytes(client.requests_RUDP))
						client.requests_RUDP.clear()
					if client.requests_UDP.size() > 0:
						peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_UNRELIABLE_ORDERED
						peer.set_target_peer(client.peer_id)
						peer.put_packet(var_to_bytes(client.requests_UDP))
						client.requests_UDP.clear()

				# HOST: Check for incoming packets
				var available = peer.get_available_packet_count()
				if available > 0:
					logger.log_info("HOST has " + str(available) + " packets available")

				# HOST: Process incoming packets from clients
				while peer.get_available_packet_count() > 0:
					var channel: int = peer.get_packet_channel()
					var sender_peer_id: int = peer.get_packet_peer()
					var bytes: PackedByteArray = peer.get_packet()
					logger.log_info("HOST received packet from peer " + str(sender_peer_id) + ", size: " + str(bytes.size()))

					if not peer_client_table.has(sender_peer_id):
						logger.log_warning("Unknown sender peer: " + str(sender_peer_id))
						continue

					var from: Client = peer_client_table[sender_peer_id]
					var message: Dictionary = bytes_to_var(bytes)

					if message.has(ENUMS.PACKET_VALUE.SERVER_REQUESTS):
						for request in message[ENUMS.PACKET_VALUE.SERVER_REQUESTS]:
							_process_server_request(from, request)

					if message.has(ENUMS.PACKET_VALUE.CLIENT_REQUESTS):
						for request in message[ENUMS.PACKET_VALUE.CLIENT_REQUESTS]:
							_broadcast_request(request, from, channel == 0)
			else:
				# CLIENT: Handle packet sending with proper set_target_peer(1)
				# ConnectionController._process() calls put_packet() without set_target_peer(),
				# which works for ENet (single server) but NOT for WebRTC mesh.
				# We run with higher priority (process_priority = -100) so we consume packets
				# BEFORE ConnectionController tries to send them without targeting.
				# Debug: Check what packets are available
				var has_setup = request_processor.has_packets(ENUMS.PACKET_CHANNEL.SETUP)
				var has_server = request_processor.has_packets(ENUMS.PACKET_CHANNEL.SERVER)
				var has_reliable = request_processor.has_packets(ENUMS.PACKET_CHANNEL.RELIABLE)
				var has_unreliable = request_processor.has_packets(ENUMS.PACKET_CHANNEL.UNRELIABLE)

				if has_setup or has_server or has_reliable or has_unreliable:
					logger.log_info("CLIENT has packets - SETUP: " + str(has_setup) + ", SERVER: " + str(has_server) + ", RELIABLE: " + str(has_reliable) + ", UNRELIABLE: " + str(has_unreliable))

				peer.set_target_peer(1) # All client packets go to host

				if has_setup:
					logger.log_info("CLIENT sending SETUP packet to host")
					peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_RELIABLE
					peer.put_packet(request_processor.package_requests(ENUMS.PACKET_CHANNEL.SETUP))
				if has_server:
					logger.log_info("CLIENT sending SERVER packet to host")
					peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_RELIABLE
					peer.put_packet(request_processor.package_requests(ENUMS.PACKET_CHANNEL.SERVER))
				if has_reliable:
					logger.log_info("CLIENT sending RELIABLE packet to host")
					peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_RELIABLE
					peer.put_packet(request_processor.package_requests(ENUMS.PACKET_CHANNEL.RELIABLE))
				if has_unreliable:
					logger.log_info("CLIENT sending UNRELIABLE packet to host")
					peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_UNRELIABLE_ORDERED
					peer.put_packet(request_processor.package_requests(ENUMS.PACKET_CHANNEL.UNRELIABLE))

				# CLIENT: Also handle receiving packets from host
				# (ConnectionController also does this, but we do it here for consistency)
				while peer.get_available_packet_count() > 0:
					var bytes: PackedByteArray = peer.get_packet()
					logger.log_info("CLIENT received packet from host, size: " + str(bytes.size()))
					request_processor.unpack_packet(bytes)


## Process server requests from clients (host only)
func _process_server_request(from: Client, request: Array) -> void:
	var request_type: int = request[ENUMS.DATA.REQUEST_TYPE]
	logger.log_info("Received server request: " + str(ENUMS.REQUEST_TYPE.keys()[request_type]) + " from " + str(from.client_id))

	match (request_type):
		ENUMS.REQUEST_TYPE.SET_CLIENT_ID:
			from.client_id = request[ENUMS.DATA.NAME]
		ENUMS.REQUEST_TYPE.JOIN_LOBBY:
			_join_lobby_request(from, request)
		ENUMS.REQUEST_TYPE.LEAVE_LOBBY:
			_leave_lobby_request(from)
		ENUMS.REQUEST_TYPE.OPEN_LOBBY:
			local_lobby_open = true
		ENUMS.REQUEST_TYPE.CLOSE_LOBBY:
			local_lobby_open = false
		ENUMS.REQUEST_TYPE.SET_GDSYNC_OWNER:
			_set_owner_request(from, request)
		ENUMS.REQUEST_TYPE.SET_LOBBY_TAG:
			_set_lobby_tag_request(from, request)
		ENUMS.REQUEST_TYPE.ERASE_LOBBY_TAG:
			_erase_lobby_tag_request(from, request)
		ENUMS.REQUEST_TYPE.SET_LOBBY_DATA:
			_set_lobby_data_request(from, request)
		ENUMS.REQUEST_TYPE.ERASE_LOBBY_DATA:
			_erase_lobby_data_request(from, request)
		ENUMS.REQUEST_TYPE.SET_PLAYER_USERNAME:
			_set_player_username_request(from, request)
		ENUMS.REQUEST_TYPE.SET_PLAYER_DATA:
			_set_player_data_request(from, request)
		ENUMS.REQUEST_TYPE.ERASE_PLAYER_DATA:
			_erase_player_data_request(from, request)


## Broadcast a request from one client to others
func _broadcast_request(request: Array, from: Client, reliable: bool) -> void:
	if not from.valid:
		return

	var peers: Array = _get_target_peers(request, from)
	for client in peers:
		if connection_controller.USE_SENDER_ID:
			_set_sender_id(from, client, reliable)
		_put_request(request, client, reliable)


func _get_target_peers(request: Array, from: Client) -> Array:
	var targets: Array = []
	if from.valid:
		var target_client: int = int(request[int(ENUMS.DATA.TARGET_CLIENT)])
		if target_client >= 0:
			if lobby_client_table.has(target_client):
				targets.append(lobby_client_table[target_client])
		else:
			return from.lobby_targets
	return targets


func _set_sender_id(from: Client, client: Client, reliable: bool) -> void:
	if not connection_controller.USE_SENDER_ID:
		return
	_put_request([
		int(ENUMS.REQUEST_TYPE.MESSAGE),
		int(ENUMS.MESSAGE_TYPE.SET_SENDER_ID),
		from.client_id
	], client, reliable)


func _put_request(request: Array, client: Client, reliable: bool) -> void:
	if reliable:
		client.requests_RUDP.append(request)
	else:
		client.requests_UDP.append(request)


func _send_message(message: int, client: Client, value=null, value2=null, value3=null) -> void:
	if client == null:
		return
	if value3 != null:
		_put_request([int(ENUMS.REQUEST_TYPE.MESSAGE), message, value, value2, value3], client, true)
	elif value2 != null:
		_put_request([int(ENUMS.REQUEST_TYPE.MESSAGE), message, value, value2], client, true)
	elif value != null:
		_put_request([int(ENUMS.REQUEST_TYPE.MESSAGE), message, value], client, true)
	else:
		_put_request([int(ENUMS.REQUEST_TYPE.MESSAGE), message], client, true)


## Handle join lobby request from client
func _join_lobby_request(from: Client, request: Array) -> void:
	if local_lobby_name == "":
		return

	if not local_lobby_open:
		_send_message(ENUMS.MESSAGE_TYPE.LOBBY_JOIN_FAILED, from, local_lobby_name, ENUMS.LOBBY_JOIN_ERROR.LOBBY_IS_CLOSED)
		return

	if local_lobby_player_limit > 0 and lobby_client_table.size() >= local_lobby_player_limit:
		_send_message(ENUMS.MESSAGE_TYPE.LOBBY_JOIN_FAILED, from, local_lobby_name, ENUMS.LOBBY_JOIN_ERROR.LOBBY_IS_FULL)
		return

	var password: String = request[ENUMS.LOBBY_DATA.PASSWORD]
	if local_lobby_password != "" and password != local_lobby_password:
		_send_message(ENUMS.MESSAGE_TYPE.LOBBY_JOIN_FAILED, from, local_lobby_name, ENUMS.LOBBY_JOIN_ERROR.INCORRECT_PASSWORD)
		return

	if connection_controller.UNIQUE_USERNAMES:
		for client in lobby_client_table.values():
			if client.username == from.username:
				_send_message(ENUMS.MESSAGE_TYPE.LOBBY_JOIN_FAILED, from, local_lobby_name, ENUMS.LOBBY_JOIN_ERROR.DUPLICATE_USERNAME)
				return

	from.valid = true
	lobby_client_table[from.client_id] = from

	# _send_message(ENUMS.MESSAGE_TYPE.LOBBY_JOINED, from, local_lobby_name)
	_send_message(ENUMS.MESSAGE_TYPE.LOBBY_JOINED, from, current_room_code)
	_send_message(ENUMS.MESSAGE_TYPE.HOST_CHANGED, from, GDSync.get_client_id())
	_send_message(ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED, from, get_lobby_dictionary(true))

	for client_id in lobby_client_table:
		var client: Client = lobby_client_table[client_id]
		client.construct_lobby_targets(lobby_client_table)

		if client != from:
			_send_message(ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED, client, from.collect_player_data())
			_send_message(ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED, from, client.collect_player_data())
			_send_message(ENUMS.MESSAGE_TYPE.CLIENT_JOINED, client, from.client_id)

		_send_message(ENUMS.MESSAGE_TYPE.CLIENT_JOINED, from, client.client_id)

	for node_path in local_owner_cache:
		_send_message(ENUMS.MESSAGE_TYPE.SET_GDSYNC_OWNER, from, node_path, local_owner_cache[node_path])

	# Update player count on signaling server
	if current_room_code != "":
		_update_player_count_on_server()

	logger.log_info("Client " + str(from.client_id) + " joined lobby " + local_lobby_name)


## Handle leave lobby request from client
func _leave_lobby_request(from: Client) -> void:
	logger.log_info("Client " + str(from.client_id) + " leaving lobby")

	if lobby_client_table.has(from.client_id):
		lobby_client_table.erase(from.client_id)

		if from.client_id != GDSync.get_client_id():
			for client_id in lobby_client_table:
				var other_client: Client = lobby_client_table[client_id]
				other_client.construct_lobby_targets(lobby_client_table)

				if other_client != from:
					_send_message(ENUMS.MESSAGE_TYPE.CLIENT_LEFT, other_client, from.client_id)
		else:
			for client_id in lobby_client_table:
				var other_client: Client = lobby_client_table[client_id]
				if other_client != from:
					_send_message(ENUMS.MESSAGE_TYPE.KICKED, other_client)
			clear_lobby_data()

	if peer_client_table.has(from.peer_id):
		peer_client_table.erase(from.peer_id)

	# Update player count on signaling server
	if current_room_code != "":
		_update_player_count_on_server()


func _set_owner_request(from: Client, request: Array) -> void:
	if not from.valid:
		return
	var node_path = request[ENUMS.DATA.NAME]
	var owner_id = request[ENUMS.DATA.VALUE]
	if owner_id == null or owner_id == -1:
		if local_owner_cache.has(node_path):
			local_owner_cache.erase(node_path)
	else:
		local_owner_cache[node_path] = owner_id

	for client_id in lobby_client_table:
		_send_message(ENUMS.MESSAGE_TYPE.SET_GDSYNC_OWNER, lobby_client_table[client_id], node_path, owner_id)


func _set_lobby_tag_request(_from: Client, request: Array) -> void:
	var key = request[ENUMS.LOBBY_DATA.NAME]
	var value = request[ENUMS.LOBBY_DATA.VALUE]
	local_lobby_tags[key] = value

	for client in lobby_client_table.values():
		_send_message(ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED, client, get_lobby_dictionary(true))
		_send_message(ENUMS.MESSAGE_TYPE.LOBBY_TAGS_CHANGED, client, key)


func _erase_lobby_tag_request(_from: Client, request: Array) -> void:
	var key = request[ENUMS.LOBBY_DATA.NAME]
	if local_lobby_tags.has(key):
		local_lobby_tags.erase(key)
		for client in lobby_client_table.values():
			_send_message(ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED, client, get_lobby_dictionary(true))
			_send_message(ENUMS.MESSAGE_TYPE.LOBBY_TAGS_CHANGED, client, key)


func _set_lobby_data_request(_from: Client, request: Array) -> void:
	var key = request[ENUMS.LOBBY_DATA.NAME]
	var value = request[ENUMS.LOBBY_DATA.VALUE]
	local_lobby_data[key] = value

	for client in lobby_client_table.values():
		_send_message(ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED, client, get_lobby_dictionary(true))
		_send_message(ENUMS.MESSAGE_TYPE.LOBBY_DATA_CHANGED, client, key)


func _erase_lobby_data_request(_from: Client, request: Array) -> void:
	var key = request[ENUMS.LOBBY_DATA.NAME]
	if local_lobby_data.has(key):
		local_lobby_data.erase(key)
		for client in lobby_client_table.values():
			_send_message(ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED, client, get_lobby_dictionary(true))
			_send_message(ENUMS.MESSAGE_TYPE.LOBBY_DATA_CHANGED, client, key)


func _set_player_username_request(from: Client, request: Array) -> void:
	from.username = request[ENUMS.DATA.NAME]
	for client in from.lobby_targets:
		_send_message(ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED, client, from.collect_player_data())
		_send_message(ENUMS.MESSAGE_TYPE.PLAYER_DATA_CHANGED, client, from.client_id, "Username")


func _set_player_data_request(from: Client, request: Array) -> void:
	var key = request[ENUMS.DATA.NAME]
	from.player_data[key] = request[ENUMS.DATA.VALUE]
	for client in from.lobby_targets:
		_send_message(ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED, client, from.collect_player_data())
		_send_message(ENUMS.MESSAGE_TYPE.PLAYER_DATA_CHANGED, client, from.client_id, key)


func _erase_player_data_request(from: Client, request: Array) -> void:
	var key = request[ENUMS.DATA.NAME]
	if from.player_data.has(key):
		from.player_data.erase(key)
		for client in from.lobby_targets:
			_send_message(ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED, from, from.collect_player_data())
			_send_message(ENUMS.MESSAGE_TYPE.PLAYER_DATA_CHANGED, from, from.client_id, key)


## Apply custom signaling server URL to PackRTC
func _apply_signaling_url() -> void:
	if signaling_server_url != "":
		PackRTC.packrtc_url = signaling_server_url
		logger.log_info(
			"Using custom signaling server: " + signaling_server_url,
			"[LocalServer-Web]"
		)


## Set the signaling server URL (call before creating/joining lobbies)
func set_signaling_server(url: String) -> void:
	signaling_server_url = url
	_apply_signaling_url()


## Update room metadata on signaling server after PackRTC creates the room
## PackRTC.host() doesn't send lobby name/public/player_limit, so we send it separately
func _update_room_metadata(code: String, lobby_name: String, public: bool, player_limit: int) -> void:
	if signaling_server_url == "":
		return

	var http = HTTPRequest.new()
	add_child(http)

	var url = signaling_server_url + "/session/update/" + code
	var body = JSON.stringify({
		"lobby_name": lobby_name,
		"public": public,
		"player_limit": player_limit
	})

	var headers = ["Content-Type: application/json"]
	var error = http.request(url, headers, HTTPClient.METHOD_POST, body)

	if error != OK:
		logger.log_error("Failed to update room metadata: " + str(error))
		http.queue_free()
		return

	# Wait for response
	var result = await http.request_completed
	http.queue_free()

	if result[1] == 200:
		logger.log_info("Room metadata updated: " + lobby_name)
	else:
		logger.log_error("Failed to update room metadata, status: " + str(result[1]))


## Close room on signaling server (called when host leaves)
func _close_room_on_server(code: String) -> void:
	if signaling_server_url == "":
		return

	var http = HTTPRequest.new()
	add_child(http)

	var url = signaling_server_url + "/session/close/" + code
	var error = http.request(url, [], HTTPClient.METHOD_POST)

	if error != OK:
		logger.log_error("Failed to close room: " + str(error))
		http.queue_free()
		return

	# Wait for response (fire and forget, but clean up the node)
	var result = await http.request_completed
	http.queue_free()

	if result[1] == 200:
		logger.log_info("Room closed on server: " + code)
	else:
		logger.log_error("Failed to close room, status: " + str(result[1]))


## Update player count on signaling server (for lobby discovery)
func _update_player_count_on_server() -> void:
	if signaling_server_url == "" or current_room_code == "":
		return

	var player_count = lobby_client_table.size()
	logger.log_info("Updating player count on server: " + str(player_count))

	var http = HTTPRequest.new()
	add_child(http)

	var url = signaling_server_url + "/session/players/" + current_room_code
	var body = JSON.stringify({"player_count": player_count})
	var headers = ["Content-Type: application/json"]
	var error = http.request(url, headers, HTTPClient.METHOD_POST, body)

	if error != OK:
		logger.log_error("Failed to update player count: " + str(error))
		http.queue_free()
		return

	# Wait for response
	var result = await http.request_completed
	http.queue_free()

	if result[1] != 200:
		logger.log_error("Failed to update player count, status: " + str(result[1]))


# Stub functions to maintain API compatibility
func perform_local_scan() -> void:
	# Not needed for WebRTC - signaling server handles discovery
	pass


func get_lobby_dictionary(with_data: bool = false) -> Dictionary:
	var dict: Dictionary = {
		"Name": local_lobby_name,
		"PlayerCount": lobby_client_table.size() + 1, # +1 for host
		"PlayerLimit": local_lobby_player_limit,
		"Public": local_lobby_public,
		"Open": local_lobby_open,
		"Tags": local_lobby_tags,
		"HasPassword": local_lobby_password != "",
		"Host": GDSync.player_get_data(GDSync.get_client_id(), "Username", ""),
		"Code": current_room_code if current_room_code else ""
	}

	if with_data:
		dict["Data"] = local_lobby_data

	return dict


## Get the current room code (for sharing with other players to join)
func get_room_code() -> String:
	return current_room_code
