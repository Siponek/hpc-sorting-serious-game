extends Node

## LocalServerSignaling.gd
## WebRTC-based replacement for GD-Sync's LocalServer.gd
## Uses SignalingClient for lobby events and PackRTC for WebRTC connections

## Signaling server URL. Set this before creating/joining lobbies.
var signaling_server_url: String = "http://localhost:3000"

## The room code generated by the signaling server (shared to let others join)
var current_room_code: String = ""

var connection_controller
var request_processor
var session_controller

# Lobby state (mirrors original LocalServer.gd)
var local_lobby_name: String = ""
var local_lobby_password: String = ""
var local_lobby_public: bool = false
var local_lobby_open: bool = true
var local_lobby_player_limit: int = 0

var local_lobby_data: Dictionary = {}
var local_lobby_tags: Dictionary = {}
var local_owner_cache: Dictionary = {}

var found_lobbies: Dictionary = {}

var peer_client_table: Dictionary = {}
var lobby_client_table: Dictionary = {}

# WebRTC specific
var rtc_session: PRSession = null
var is_host: bool = false
var _is_initialized: bool = false

var my_current_client: Client = null

# Signaling client
var _signaling: SignalingClient = null

@onready var logger = CustomLogger.get_logger(self)


# Client class (mirrors original)
class Client:
	extends RefCounted
	var valid: bool = false
	var client_id: int = -1
	var peer_id: int = -1
	var username: String
	var player_data: Dictionary = {}

	var requests_SERVER: Array = []
	var requests_RUDP: Array = []
	var requests_UDP: Array = []
	var lobby_targets: Array = []

	func construct_lobby_targets(clients: Dictionary) -> void:
		lobby_targets = clients.values()
		lobby_targets.erase(self)

	func collect_player_data() -> Dictionary:
		var data: Dictionary = player_data.duplicate()
		data["ID"] = client_id
		data["Username"] = username
		return data


func _ready() -> void:
	name = "LocalServer"
	connection_controller = GDSync._connection_controller
	request_processor = GDSync._request_processor
	session_controller = GDSync._session_controller

	# Configure PackRTC
	PackRTC.game_channel = "gdsync-hpc-sorting"
	PackRTC.use_mesh = false
	PackRTC.enable_debug = OS.has_feature("editor")

	# Create signaling client
	_signaling = SignalingClient.new()
	_signaling.name = "SignalingClient"
	add_child(_signaling)
	_connect_signaling_signals()

	process_priority = -100
	set_process(false)

	logger.log_info("LocalServerSignaling initialized for web platform.")
	my_current_client = Client.new()
	my_current_client.valid = true
	my_current_client.client_id = multiplayer.get_unique_id()


func _connect_signaling_signals() -> void:
	_signaling.connected.connect(_on_signaling_connected)
	_signaling.disconnected.connect(_on_signaling_disconnected)
	_signaling.connection_error.connect(_on_signaling_error)
	_signaling.lobby_created.connect(_on_lobby_created)
	_signaling.lobby_joined.connect(_on_lobby_joined)
	_signaling.lobby_left.connect(_on_lobby_left)
	_signaling.lobby_closed.connect(_on_lobby_closed)
	_signaling.lobby_list_received.connect(_on_lobby_list_received)
	_signaling.peer_joined.connect(_on_peer_joined_signaling)
	_signaling.peer_left.connect(_on_peer_left_signaling)
	_signaling.error_received.connect(_on_signaling_error_received)


func reset_multiplayer() -> void:
	logger.log_info("Resetting web multiplayer state.")

	if rtc_session:
		rtc_session.queue_free()
		rtc_session = null

	set_process(false)
	found_lobbies.clear()
	clear_lobby_data()
	_is_initialized = false


func close_lobby() -> void:
	logger.log_info("Explicitly closing lobby.")

	if is_host and current_room_code != "":
		_signaling.leave_lobby()

	reset_multiplayer()


func clear_lobby_data() -> void:
	logger.log_info("Clear lobby data.")
	local_lobby_name = ""
	local_lobby_password = ""
	current_room_code = ""

	local_lobby_data.clear()
	local_lobby_tags.clear()
	local_owner_cache.clear()
	peer_client_table.clear()
	lobby_client_table.clear()
	is_host = false


func start_local_peer() -> bool:
	logger.log_info("Web platform: WebRTC mode - no UDP binding needed.")
	_is_initialized = true

	# Connect to signaling server
	if not _signaling.is_connected_to_server():
		_signaling.connect_to_server(signaling_server_url)

	return true


func create_local_lobby(
	lobby_name: String,
	password: String = "",
	public: bool = true,
	player_limit: int = 0,
	tags: Dictionary = {},
	data: Dictionary = {}
) -> void:
	logger.log_info("Creating web lobby: " + lobby_name)

	# Validate lobby parameters
	if lobby_name.length() < 3:
		GDSync.lobby_creation_failed.emit.call_deferred(
			lobby_name, ENUMS.LOBBY_CREATION_ERROR.NAME_TOO_SHORT
		)
		return
	if lobby_name.length() > 32:
		GDSync.lobby_creation_failed.emit.call_deferred(
			lobby_name, ENUMS.LOBBY_CREATION_ERROR.NAME_TOO_LONG
		)
		return

	# Store lobby state
	local_lobby_name = lobby_name
	local_lobby_password = password
	local_lobby_public = public
	local_lobby_player_limit = player_limit
	local_lobby_tags = tags
	local_lobby_data = data

	# Ensure connected to signaling server
	if not _signaling.is_connected_to_server():
		await _signaling.connect_to_server(signaling_server_url)
		await _signaling.connected

	# Create lobby via signaling server
	var player_data = {
		"name":
		GDSync.player_get_data(GDSync.get_client_id(), "Username", "Host")
		# Create lobby via signaling server
	}
	_signaling.create_lobby(lobby_name, public, player_limit, player_data)


func join_lobby(lobby_name: String, password: String) -> void:
	var code = lobby_name.to_upper().strip_edges()
	logger.log_info("Joining web lobby with code: " + code)

	local_lobby_name = lobby_name
	local_lobby_password = password

	# Ensure connected to signaling server
	if not _signaling.is_connected_to_server():
		await _signaling.connect_to_server(signaling_server_url)
		await _signaling.connected

	# Join lobby via signaling server
	var player_data = {
		"name":
		GDSync.player_get_data(GDSync.get_client_id(), "Username", "Player")
		# Join lobby via signaling server
	}
	_signaling.join_lobby(code, player_data)


func get_public_lobbies() -> void:
	# Ensure connected to signaling server
	if not _signaling.is_connected_to_server():
		await _signaling.connect_to_server(signaling_server_url)
		await _signaling.connected

	_signaling.list_lobbies()


func get_public_lobby(lobby_name: String) -> void:
	for lobby_data in found_lobbies.values():
		if (
			lobby_data.get("Public", false)
			and lobby_data.get("Name", "") == lobby_name
		):
			GDSync.lobby_received.emit.call_deferred(lobby_data)
			return

	GDSync.lobby_received.emit.call_deferred({})


func is_local_server() -> bool:
	return local_lobby_name != "" and is_host


# =============================================================================
# Signaling Event Handlers
# =============================================================================


func _on_signaling_connected() -> void:
	logger.log_info("Connected to signaling server")


func _on_signaling_disconnected() -> void:
	logger.log_warning("Disconnected from signaling server")


func _on_signaling_error(error: String) -> void:
	logger.log_error("Signaling error: " + error)


func _on_signaling_error_received(code: String, message: String) -> void:
	logger.log_error("Server error: %s - %s" % [code, message])

	# Map error codes to GDSync errors
	match code:
		"LOBBY_NOT_FOUND":
			GDSync.lobby_join_failed.emit.call_deferred(
				local_lobby_name, ENUMS.LOBBY_JOIN_ERROR.LOBBY_DOES_NOT_EXIST
			)
		"LOBBY_FULL":
			GDSync.lobby_join_failed.emit.call_deferred(
				local_lobby_name, ENUMS.LOBBY_JOIN_ERROR.LOBBY_IS_FULL
			)
		"LOBBY_CLOSED":
			GDSync.lobby_join_failed.emit.call_deferred(
				local_lobby_name, ENUMS.LOBBY_JOIN_ERROR.LOBBY_IS_CLOSED
			)


func _on_lobby_created(
	code: String, lobby_name: String, host_id: int, your_id: int
) -> void:
	logger.log_info(
		(
			"Lobby created via signaling: %s (host=%d, me=%d)"
			% [code, host_id, your_id]
		)
	)

	current_room_code = code
	is_host = true

	# Now start PackRTC to establish WebRTC connection
	PackRTC.game_channel = "gdsync-" + lobby_name.to_lower().replace(" ", "-")
	PackRTC.packrtc_url = signaling_server_url

	var session = await PackRTC.host()
	if session is PRSession:
		await _setup_rtc_session(session, true)

		# Add to found lobbies
		var lobby_dict: Dictionary = get_lobby_dictionary()
		lobby_dict["Code"] = current_room_code
		found_lobbies[local_lobby_name] = lobby_dict

		GDSync.lobby_created.emit.call_deferred(current_room_code)
		GDSync.client_joined.emit.call_deferred(my_current_client.client_id)
	else:
		logger.log_error("Failed to create WebRTC session: " + str(session))
		GDSync.lobby_creation_failed.emit.call_deferred(
			lobby_name, ENUMS.LOBBY_CREATION_ERROR.LOCAL_PORT_ERROR
		)


func _on_lobby_joined(
	code: String, lobby_name: String, host_id: int, your_id: int, players: Array
) -> void:
	logger.log_info(
		(
			"Lobby joined via signaling: %s (host=%d, me=%d, players=%d)"
			% [code, host_id, your_id, players.size()]
		)
	)

	current_room_code = code
	is_host = false

	# Now start PackRTC to establish WebRTC connection to host
	PackRTC.packrtc_url = signaling_server_url

	var session = await PackRTC.join(code)
	if session is PRSession:
		await _setup_rtc_session(session, false)

		# Add existing players from server and emit client_joined for each
		for player in players:
			var peer_id = player.get("id", -1)
			if peer_id > 0 and peer_id != your_id:
				var client = Client.new()
				client.peer_id = peer_id
				client.client_id = peer_id
				client.valid = true
				client.player_data = player.get("player", {})
				peer_client_table[peer_id] = client
				lobby_client_table[peer_id] = client
				# Notify GDSync about existing players
				GDSync.client_joined.emit.call_deferred(peer_id)

		# Emit lobby_joined first, then client_joined for self
		GDSync.lobby_joined.emit.call_deferred(code)
		# Also emit client_joined for ourselves so ConnectionManager tracks us
		GDSync.client_joined.emit.call_deferred(my_current_client.client_id)
	else:
		logger.log_error("Failed to join WebRTC session: " + str(session))
		GDSync.lobby_join_failed.emit.call_deferred(
			lobby_name, ENUMS.LOBBY_JOIN_ERROR.LOBBY_DOES_NOT_EXIST
		)


func _on_lobby_left(code: String) -> void:
	logger.log_info("Left lobby: " + code)
	reset_multiplayer()


func _on_lobby_closed(code: String, reason: String) -> void:
	logger.log_info("Lobby closed: %s (reason: %s)" % [code, reason])

	# Notify GDSync that we were kicked
	if not is_host:
		GDSync.kicked.emit.call_deferred()

	reset_multiplayer()


func _on_lobby_list_received(lobbies: Array) -> void:
	logger.log_info("Received %d lobbies from server" % lobbies.size())

	# Convert to GDSync format
	var gdsync_lobbies: Array = []
	for lobby in lobbies:
		var gdsync_lobby = {
			"Name": lobby.get("name", ""),
			"Code": lobby.get("code", ""),
			"PlayerCount": lobby.get("players", 0),
			"PlayerLimit": lobby.get("player_limit", 0),
			"Public": lobby.get("public", true),
			"Open": true,
			"HasPassword": false,
		}
		gdsync_lobbies.append(gdsync_lobby)
		found_lobbies[gdsync_lobby["Name"]] = gdsync_lobby

	GDSync.lobbies_received.emit.call_deferred(gdsync_lobbies)


func _on_peer_joined_signaling(peer_id: int, player_data: Dictionary) -> void:
	logger.log_info("Peer joined via signaling: %d" % peer_id)

	# Create client entry
	var client = Client.new()
	client.peer_id = peer_id
	client.client_id = peer_id
	client.valid = true
	client.player_data = player_data
	peer_client_table[peer_id] = client
	lobby_client_table[peer_id] = client

	# Rebuild lobby targets
	for cid in lobby_client_table:
		lobby_client_table[cid].construct_lobby_targets(lobby_client_table)

	GDSync.client_joined.emit.call_deferred(peer_id)


func _on_peer_left_signaling(peer_id: int) -> void:
	logger.log_info("Peer left via signaling: %d" % peer_id)

	if lobby_client_table.has(peer_id):
		lobby_client_table.erase(peer_id)
	if peer_client_table.has(peer_id):
		peer_client_table.erase(peer_id)

	# Rebuild lobby targets
	for cid in lobby_client_table:
		lobby_client_table[cid].construct_lobby_targets(lobby_client_table)

	GDSync.client_left.emit.call_deferred(peer_id)


# =============================================================================
# WebRTC Session Setup
# =============================================================================


func _setup_rtc_session(session: PRSession, hosting: bool) -> void:
	rtc_session = session

	logger.log_info("Waiting for WebRTC peer to be ready...")
	await session.peer_ready

	# Set up multiplayer
	multiplayer.multiplayer_peer = session.rtc_peer
	connection_controller.client = session.rtc_peer

	# Update our client ID now that multiplayer peer is set
	my_current_client.client_id = multiplayer.get_unique_id()
	logger.log_info("Updated my client ID to: %d" % my_current_client.client_id)

	# Connect peer signals for WebRTC-level events
	session.rtc_peer.peer_connected.connect(_on_rtc_peer_connected)
	session.rtc_peer.peer_disconnected.connect(_on_rtc_peer_disconnected)

	# Configure connection controller
	if hosting:
		connection_controller.set_host(my_current_client.client_id)
	else:
		connection_controller.set_host(1)

	connection_controller.in_local_lobby = true
	connection_controller.status = ENUMS.CONNECTION_STATUS.LOCAL_CONNECTION
	connection_controller.set_process(false)

	# Add self to client tables
	var self_client = Client.new()
	self_client.peer_id = my_current_client.client_id
	self_client.client_id = my_current_client.client_id
	self_client.valid = true
	peer_client_table[my_current_client.client_id] = self_client
	lobby_client_table[my_current_client.client_id] = self_client

	set_process(true)
	logger.log_info(
		(
			"WebRTC session ready. Host: %s, My ID: %d"
			% [str(hosting), my_current_client.client_id]
		)
	)


func _on_rtc_peer_connected(id: int) -> void:
	logger.log_info("WebRTC peer connected: " + str(id))
	# Peer tracking is now handled by signaling server events


func _on_rtc_peer_disconnected(id: int) -> void:
	logger.log_info("WebRTC peer disconnected: " + str(id))
	# Peer tracking is now handled by signaling server events


# =============================================================================
# Process Loop (WebRTC packet handling)
# =============================================================================


func _process(_delta: float) -> void:
	if not rtc_session or not rtc_session.rtc_peer:
		return

	var peer = rtc_session.rtc_peer
	var status = peer.get_connection_status()

	match status:
		MultiplayerPeer.CONNECTION_DISCONNECTED:
			logger.log_info("WebRTC peer lost connection.")
			connection_controller.reset_multiplayer()
		MultiplayerPeer.CONNECTION_CONNECTING:
			peer.poll()
		MultiplayerPeer.CONNECTION_CONNECTED:
			peer.poll()

			if is_host:
				_process_host()
			else:
				_process_client()


func _process_host() -> void:
	var peer = rtc_session.rtc_peer

	# Send queued requests to clients
	for client_id in lobby_client_table.keys():
		if client_id == my_current_client.client_id:
			continue

		var client: Client = lobby_client_table[client_id]

		if (
			client.requests_RUDP.is_empty()
			and client.requests_UDP.is_empty()
			and client.requests_SERVER.is_empty()
		):
			continue

		peer.set_target_peer(client.client_id)

		for ch in [
			ENUMS.PACKET_CHANNEL.SERVER,
			ENUMS.PACKET_CHANNEL.RELIABLE,
			ENUMS.PACKET_CHANNEL.UNRELIABLE
		]:
			var pkt: PackedByteArray = request_processor.package_requests(
				client.requests_RUDP,
				client.requests_UDP,
				client.requests_SERVER,
				ch
			)
			if pkt.is_empty():
				continue

			if ch == ENUMS.PACKET_CHANNEL.UNRELIABLE:
				peer.transfer_mode = (
					MultiplayerPeer.TRANSFER_MODE_UNRELIABLE_ORDERED
				)
			else:
				peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_RELIABLE

			peer.put_packet(pkt)

		client.requests_RUDP.clear()
		client.requests_UDP.clear()
		client.requests_SERVER.clear()

	# Process incoming packets from clients
	while peer.get_available_packet_count() > 0:
		var channel: int = peer.get_packet_channel()
		var sender_peer_id: int = peer.get_packet_peer()
		var bytes: PackedByteArray = peer.get_packet()

		if not peer_client_table.has(sender_peer_id):
			logger.log_warning("Unknown sender peer: " + str(sender_peer_id))
			continue

		var from: Client = peer_client_table[sender_peer_id]
		var message: Dictionary = bytes_to_var(bytes)

		if message.has(ENUMS.PACKET_VALUE.SERVER_REQUESTS):
			for request in message[ENUMS.PACKET_VALUE.SERVER_REQUESTS]:
				_process_server_request(from, request)

		if message.has(ENUMS.PACKET_VALUE.CLIENT_REQUESTS):
			for request in message[ENUMS.PACKET_VALUE.CLIENT_REQUESTS]:
				_broadcast_request(request, from, channel == 0)


func _process_client() -> void:
	var peer = rtc_session.rtc_peer

	# Send packets to host
	var has_setup = request_processor.has_packets(ENUMS.PACKET_CHANNEL.SETUP)
	var has_server = request_processor.has_packets(ENUMS.PACKET_CHANNEL.SERVER)
	var has_reliable = request_processor.has_packets(
		ENUMS.PACKET_CHANNEL.RELIABLE
	)
	var has_unreliable = request_processor.has_packets(
		ENUMS.PACKET_CHANNEL.UNRELIABLE
	)

	peer.set_target_peer(1)

	if has_setup:
		peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_RELIABLE
		peer.put_packet(
			request_processor.package_requests(ENUMS.PACKET_CHANNEL.SETUP)
		)
	if has_server:
		peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_RELIABLE
		peer.put_packet(
			request_processor.package_requests(ENUMS.PACKET_CHANNEL.SERVER)
		)
	if has_reliable:
		peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_RELIABLE
		peer.put_packet(
			request_processor.package_requests(ENUMS.PACKET_CHANNEL.RELIABLE)
		)
	if has_unreliable:
		peer.transfer_mode = MultiplayerPeer.TRANSFER_MODE_UNRELIABLE_ORDERED
		peer.put_packet(
			request_processor.package_requests(ENUMS.PACKET_CHANNEL.UNRELIABLE)
		)

	# Receive packets from host
	while peer.get_available_packet_count() > 0:
		var bytes: PackedByteArray = peer.get_packet()
		request_processor.unpack_packet(bytes)


# =============================================================================
# Server Request Processing (Host only)
# =============================================================================


func _process_server_request(from: Client, request: Array) -> void:
	var request_type: int = request[ENUMS.DATA.REQUEST_TYPE]

	match request_type:
		ENUMS.REQUEST_TYPE.SET_CLIENT_ID:
			from.client_id = request[ENUMS.DATA.NAME]
		ENUMS.REQUEST_TYPE.JOIN_LOBBY:
			_join_lobby_request(from, request)
		ENUMS.REQUEST_TYPE.LEAVE_LOBBY:
			_leave_lobby_request(from)
		ENUMS.REQUEST_TYPE.OPEN_LOBBY:
			local_lobby_open = true
		ENUMS.REQUEST_TYPE.CLOSE_LOBBY:
			local_lobby_open = false
		ENUMS.REQUEST_TYPE.SET_GDSYNC_OWNER:
			_set_owner_request(from, request)
		ENUMS.REQUEST_TYPE.SET_LOBBY_TAG:
			_set_lobby_tag_request(from, request)
		ENUMS.REQUEST_TYPE.ERASE_LOBBY_TAG:
			_erase_lobby_tag_request(from, request)
		ENUMS.REQUEST_TYPE.SET_LOBBY_DATA:
			_set_lobby_data_request(from, request)
		ENUMS.REQUEST_TYPE.ERASE_LOBBY_DATA:
			_erase_lobby_data_request(from, request)
		ENUMS.REQUEST_TYPE.SET_PLAYER_USERNAME:
			_set_player_username_request(from, request)
		ENUMS.REQUEST_TYPE.SET_PLAYER_DATA:
			_set_player_data_request(from, request)
		ENUMS.REQUEST_TYPE.ERASE_PLAYER_DATA:
			_erase_player_data_request(from, request)


func _broadcast_request(request: Array, from: Client, reliable: bool) -> void:
	if not from.valid:
		return

	var peers: Array = _get_target_peers(request, from)
	for client in peers:
		if connection_controller.USE_SENDER_ID:
			_set_sender_id(from, client, reliable)
		_put_request(request, client, reliable)


func _get_target_peers(request: Array, from: Client) -> Array:
	var targets: Array = []
	if from.valid:
		var target_client: int = int(request[int(ENUMS.DATA.TARGET_CLIENT)])
		if target_client >= 0:
			if lobby_client_table.has(target_client):
				targets.append(lobby_client_table[target_client])
		else:
			return from.lobby_targets
	return targets


func _set_sender_id(from: Client, client: Client, reliable: bool) -> void:
	if not connection_controller.USE_SENDER_ID:
		return
	_put_request(
		[
			int(ENUMS.REQUEST_TYPE.MESSAGE),
			int(ENUMS.MESSAGE_TYPE.SET_SENDER_ID),
			from.client_id
		],
		client,
		reliable
	)


func _put_request(request: Array, client: Client, reliable: bool) -> void:
	if reliable:
		client.requests_RUDP.append(request)
	else:
		client.requests_UDP.append(request)


func _send_message(
	message: int, client: Client, value = null, value2 = null, value3 = null
) -> void:
	if client == null:
		return
	if value3 != null:
		_put_request(
			[int(ENUMS.REQUEST_TYPE.MESSAGE), message, value, value2, value3],
			client,
			true
		)
	elif value2 != null:
		_put_request(
			[int(ENUMS.REQUEST_TYPE.MESSAGE), message, value, value2],
			client,
			true
		)
	elif value != null:
		_put_request(
			[int(ENUMS.REQUEST_TYPE.MESSAGE), message, value], client, true
		)
	else:
		_put_request([int(ENUMS.REQUEST_TYPE.MESSAGE), message], client, true)


func _join_lobby_request(from: Client, request: Array) -> void:
	if local_lobby_name == "" or current_room_code == "":
		return

	if not local_lobby_open:
		_send_message(
			ENUMS.MESSAGE_TYPE.LOBBY_JOIN_FAILED,
			from,
			current_room_code,
			ENUMS.LOBBY_JOIN_ERROR.LOBBY_IS_CLOSED
		)
		return

	if (
		local_lobby_player_limit > 0
		and lobby_client_table.size() >= local_lobby_player_limit
	):
		_send_message(
			ENUMS.MESSAGE_TYPE.LOBBY_JOIN_FAILED,
			from,
			current_room_code,
			ENUMS.LOBBY_JOIN_ERROR.LOBBY_IS_FULL
		)
		return

	var password: String = request[ENUMS.LOBBY_DATA.PASSWORD]
	if local_lobby_password != "" and password != local_lobby_password:
		_send_message(
			ENUMS.MESSAGE_TYPE.LOBBY_JOIN_FAILED,
			from,
			current_room_code,
			ENUMS.LOBBY_JOIN_ERROR.INCORRECT_PASSWORD
		)
		return

	if connection_controller.UNIQUE_USERNAMES:
		for client in lobby_client_table.values():
			if client.username == from.username:
				_send_message(
					ENUMS.MESSAGE_TYPE.LOBBY_JOIN_FAILED,
					from,
					current_room_code,
					ENUMS.LOBBY_JOIN_ERROR.DUPLICATE_USERNAME
				)
				return

	from.valid = true
	lobby_client_table[from.client_id] = from

	_send_message(ENUMS.MESSAGE_TYPE.LOBBY_JOINED, from, current_room_code)
	_send_message(ENUMS.MESSAGE_TYPE.HOST_CHANGED, from, GDSync.get_client_id())
	_send_message(
		ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED, from, get_lobby_dictionary(true)
	)

	for client_id in lobby_client_table:
		var client: Client = lobby_client_table[client_id]
		client.construct_lobby_targets(lobby_client_table)

		if client != from:
			_send_message(
				ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED,
				client,
				from.collect_player_data()
			)
			_send_message(
				ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED,
				from,
				client.collect_player_data()
			)
			_send_message(
				ENUMS.MESSAGE_TYPE.CLIENT_JOINED, client, from.client_id
			)

		_send_message(ENUMS.MESSAGE_TYPE.CLIENT_JOINED, from, client.client_id)

	for node_path in local_owner_cache:
		_send_message(
			ENUMS.MESSAGE_TYPE.SET_GDSYNC_OWNER,
			from,
			node_path,
			local_owner_cache[node_path]
		)


func _leave_lobby_request(from: Client) -> void:
	if lobby_client_table.has(from.client_id):
		lobby_client_table.erase(from.client_id)

		if from.client_id != GDSync.get_client_id():
			for client_id in lobby_client_table:
				var other_client: Client = lobby_client_table[client_id]
				other_client.construct_lobby_targets(lobby_client_table)

				if other_client != from:
					_send_message(
						ENUMS.MESSAGE_TYPE.CLIENT_LEFT,
						other_client,
						from.client_id
					)
		else:
			for client_id in lobby_client_table:
				var other_client: Client = lobby_client_table[client_id]
				if other_client != from:
					_send_message(ENUMS.MESSAGE_TYPE.KICKED, other_client)
			clear_lobby_data()

	if peer_client_table.has(from.peer_id):
		peer_client_table.erase(from.peer_id)


func _set_owner_request(from: Client, request: Array) -> void:
	if not from.valid:
		return
	var node_path = request[ENUMS.DATA.NAME]
	var owner_id = request[ENUMS.DATA.VALUE]
	if owner_id == null or owner_id == -1:
		if local_owner_cache.has(node_path):
			local_owner_cache.erase(node_path)
	else:
		local_owner_cache[node_path] = owner_id

	for client_id in lobby_client_table:
		_send_message(
			ENUMS.MESSAGE_TYPE.SET_GDSYNC_OWNER,
			lobby_client_table[client_id],
			node_path,
			owner_id
		)


func _set_lobby_tag_request(_from: Client, request: Array) -> void:
	var key = request[ENUMS.LOBBY_DATA.NAME]
	var value = request[ENUMS.LOBBY_DATA.VALUE]
	local_lobby_tags[key] = value

	for client in lobby_client_table.values():
		_send_message(
			ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED,
			client,
			get_lobby_dictionary(true)
		)
		_send_message(ENUMS.MESSAGE_TYPE.LOBBY_TAGS_CHANGED, client, key)


func _erase_lobby_tag_request(_from: Client, request: Array) -> void:
	var key = request[ENUMS.LOBBY_DATA.NAME]
	if local_lobby_tags.has(key):
		local_lobby_tags.erase(key)
		for client in lobby_client_table.values():
			_send_message(
				ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED,
				client,
				get_lobby_dictionary(true)
			)
			_send_message(ENUMS.MESSAGE_TYPE.LOBBY_TAGS_CHANGED, client, key)


func _set_lobby_data_request(_from: Client, request: Array) -> void:
	var key = request[ENUMS.LOBBY_DATA.NAME]
	var value = request[ENUMS.LOBBY_DATA.VALUE]
	local_lobby_data[key] = value

	for client in lobby_client_table.values():
		_send_message(
			ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED,
			client,
			get_lobby_dictionary(true)
		)
		_send_message(ENUMS.MESSAGE_TYPE.LOBBY_DATA_CHANGED, client, key)


func _erase_lobby_data_request(_from: Client, request: Array) -> void:
	var key = request[ENUMS.LOBBY_DATA.NAME]
	if local_lobby_data.has(key):
		local_lobby_data.erase(key)
		for client in lobby_client_table.values():
			_send_message(
				ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED,
				client,
				get_lobby_dictionary(true)
			)
			_send_message(ENUMS.MESSAGE_TYPE.LOBBY_DATA_CHANGED, client, key)


func _set_player_username_request(from: Client, request: Array) -> void:
	from.username = request[ENUMS.DATA.NAME]
	for client in from.lobby_targets:
		_send_message(
			ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED,
			client,
			from.collect_player_data()
		)
		_send_message(
			ENUMS.MESSAGE_TYPE.PLAYER_DATA_CHANGED,
			client,
			from.client_id,
			"Username"
		)


func _set_player_data_request(from: Client, request: Array) -> void:
	var key = request[ENUMS.DATA.NAME]
	from.player_data[key] = request[ENUMS.DATA.VALUE]
	for client in from.lobby_targets:
		_send_message(
			ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED,
			client,
			from.collect_player_data()
		)
		_send_message(
			ENUMS.MESSAGE_TYPE.PLAYER_DATA_CHANGED, client, from.client_id, key
		)


func _erase_player_data_request(from: Client, request: Array) -> void:
	var key = request[ENUMS.DATA.NAME]
	if from.player_data.has(key):
		from.player_data.erase(key)
		for client in from.lobby_targets:
			_send_message(
				ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED,
				from,
				from.collect_player_data()
			)
			_send_message(
				ENUMS.MESSAGE_TYPE.PLAYER_DATA_CHANGED,
				from,
				from.client_id,
				key
			)


# =============================================================================
# Utility Methods
# =============================================================================


func set_signaling_server(url: String) -> void:
	signaling_server_url = url


func perform_local_scan() -> void:
	pass  # Not needed - signaling server handles discovery


func get_lobby_dictionary(with_data: bool = false) -> Dictionary:
	var dict: Dictionary = {
		"Name": local_lobby_name,
		"PlayerCount": lobby_client_table.size() + 1,
		"PlayerLimit": local_lobby_player_limit,
		"Public": local_lobby_public,
		"Open": local_lobby_open,
		"Tags": local_lobby_tags,
		"HasPassword": local_lobby_password != "",
		"Host": GDSync.player_get_data(GDSync.get_client_id(), "Username", ""),
		"Code": current_room_code if current_room_code else ""
	}

	if with_data:
		dict["Data"] = local_lobby_data

	return dict


func get_room_code() -> String:
	return current_room_code
