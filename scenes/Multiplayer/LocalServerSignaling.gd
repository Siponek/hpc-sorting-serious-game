extends Node

## LocalServerSignaling.gd
## HTTP-based replacement for GD-Sync's LocalServer.gd
## Uses SignalingClient for lobby events and HTTP for game packet relay
## No WebRTC - all communication goes through the signaling server

## Signaling server URL. Set this before creating/joining lobbies.
var signaling_server_url: String = "http://localhost:3000"

## The room code generated by the signaling server (shared to let others join)
var current_room_code: String = ""

var connection_controller
var request_processor
var session_controller

# Lobby state (mirrors original LocalServer.gd)
var local_lobby_name: String = ""
var local_lobby_password: String = ""
var local_lobby_public: bool = false
var local_lobby_open: bool = true
var local_lobby_player_limit: int = 0

var local_lobby_data: Dictionary = {}
var local_lobby_tags: Dictionary = {}
var local_owner_cache: Dictionary = {}

var found_lobbies: Dictionary = {}

var peer_client_table: Dictionary = {}
var lobby_client_table: Dictionary = {}

# State
var is_host: bool = false
var _is_initialized: bool = false

var my_current_client: Client = null

# Signaling client (HTTP + SSE based)
var _signaling: SignalingClient = null

@onready var logger = CustomLogger.get_logger(self)


# Client class (mirrors original)
class Client:
	extends RefCounted
	var valid: bool = false
	var client_id: int = -1
	var peer_id: int = -1
	var username: String
	var player_data: Dictionary = {}

	var requests_SERVER: Array = []
	var requests_RUDP: Array = []
	var requests_UDP: Array = []
	var lobby_targets: Array = []

	func construct_lobby_targets(clients: Dictionary) -> void:
		lobby_targets = clients.values()
		lobby_targets.erase(self)

	func collect_player_data() -> Dictionary:
		var data: Dictionary = player_data.duplicate()
		data["ID"] = client_id
		data["Username"] = username
		return data


func _ready() -> void:
	name = "LocalServer"
	connection_controller = GDSync._connection_controller
	request_processor = GDSync._request_processor
	session_controller = GDSync._session_controller

	# Create signaling client
	_signaling = SignalingClient.new()
	_signaling.name = "SignalingClient"
	add_child(_signaling)
	_connect_signaling_signals()

	process_priority = -100
	set_process(false)

	logger.log_info("LocalServerSignaling initialized (HTTP mode).")
	my_current_client = Client.new()
	my_current_client.valid = true
	my_current_client.client_id = 1 # Will be updated when connected


func _connect_signaling_signals() -> void:
	_signaling.connected.connect(_on_signaling_connected)
	_signaling.disconnected.connect(_on_signaling_disconnected)
	_signaling.connection_error.connect(_on_signaling_error)
	_signaling.lobby_created.connect(_on_lobby_created)
	_signaling.lobby_joined.connect(_on_lobby_joined)
	_signaling.lobby_left.connect(_on_lobby_left)
	_signaling.lobby_closed.connect(_on_lobby_closed)
	_signaling.lobby_list_received.connect(_on_lobby_list_received)
	_signaling.peer_joined.connect(_on_peer_joined_signaling)
	_signaling.peer_left.connect(_on_peer_left_signaling)
	_signaling.error_received.connect(_on_signaling_error_received)
	_signaling.game_packet_received.connect(_on_game_packet_received)


func reset_multiplayer() -> void:
	logger.log_info("Resetting web multiplayer state.")
	set_process(false)
	found_lobbies.clear()
	clear_lobby_data()
	_is_initialized = false


func close_lobby() -> void:
	logger.log_info("Explicitly closing lobby.")

	if is_host and current_room_code != "":
		_signaling.leave_lobby()

	reset_multiplayer()


func clear_lobby_data() -> void:
	logger.log_info("Clear lobby data.")
	local_lobby_name = ""
	local_lobby_password = ""
	current_room_code = ""

	local_lobby_data.clear()
	local_lobby_tags.clear()
	local_owner_cache.clear()
	peer_client_table.clear()
	lobby_client_table.clear()
	is_host = false


func start_local_peer() -> bool:
	logger.log_info("Web platform: HTTP relay mode - no UDP/WebRTC needed.")
	_is_initialized = true

	# Connect to signaling server
	if not _signaling.is_connected_to_server():
		await _signaling.connect_to_server(signaling_server_url)

	return true


func create_local_lobby(
	lobby_name: String,
	password: String = "",
	public: bool = true,
	player_limit: int = 0,
	tags: Dictionary = {},
	data: Dictionary = {}
) -> void:
	logger.log_info("Creating web lobby: " + lobby_name)

	# Validate lobby parameters
	if lobby_name.length() < 3:
		GDSync.lobby_creation_failed.emit.call_deferred(
			lobby_name, ENUMS.LOBBY_CREATION_ERROR.NAME_TOO_SHORT
		)
		return
	if lobby_name.length() > 32:
		GDSync.lobby_creation_failed.emit.call_deferred(
			lobby_name, ENUMS.LOBBY_CREATION_ERROR.NAME_TOO_LONG
		)
		return

	# Store lobby state
	local_lobby_name = lobby_name
	local_lobby_password = password
	local_lobby_public = public
	local_lobby_player_limit = player_limit
	local_lobby_tags = tags
	local_lobby_data = data

	# Ensure connected to signaling server
	if not _signaling.is_connected_to_server():
		await _signaling.connect_to_server(signaling_server_url)
		await _signaling.connected

	# Create lobby via signaling server
	var player_data = {
		"name": GDSync.player_get_data(GDSync.get_client_id(), "Username", "Host")
	}
	_signaling.create_lobby(lobby_name, public, player_limit, player_data)


func join_lobby(lobby_name: String, password: String) -> void:
	var code = lobby_name.to_upper().strip_edges()
	logger.log_info("Joining web lobby with code: " + code)

	local_lobby_name = lobby_name
	local_lobby_password = password

	# Ensure connected to signaling server
	if not _signaling.is_connected_to_server():
		await _signaling.connect_to_server(signaling_server_url)
		await _signaling.connected

	# Join lobby via signaling server
	var player_data = {
		"name": GDSync.player_get_data(GDSync.get_client_id(), "Username", "Player")
	}
	_signaling.join_lobby(code, player_data)


func get_public_lobbies() -> void:
	# Ensure connected to signaling server
	if not _signaling.is_connected_to_server():
		await _signaling.connect_to_server(signaling_server_url)
		await _signaling.connected

	_signaling.list_lobbies()


func get_public_lobby(lobby_name: String) -> void:
	for lobby_data in found_lobbies.values():
		if (
			lobby_data.get("Public", false)
			and lobby_data.get("Name", "") == lobby_name
		):
			GDSync.lobby_received.emit.call_deferred(lobby_data)
			return

	GDSync.lobby_received.emit.call_deferred({})


func is_local_server() -> bool:
	return local_lobby_name != "" and is_host


# =============================================================================
# Signaling Event Handlers
# =============================================================================


func _on_signaling_connected() -> void:
	# Server should return the same ID we sent (GDSync's client_id)
	var gdsync_id = GDSync.get_client_id()
	assert(_signaling.my_peer_id == gdsync_id,
		"LocalServerSignaling: Server returned peer_id %d but expected GDSync's client_id %d" % [_signaling.my_peer_id, gdsync_id])
	logger.log_info("Connected to signaling server with peer_id: %d (matches GDSync)" % _signaling.my_peer_id)
	# Update our local client references (ID should already match GDSync's)
	my_current_client.client_id = _signaling.my_peer_id
	my_current_client.peer_id = _signaling.my_peer_id


func _on_signaling_disconnected() -> void:
	logger.log_warning("Disconnected from signaling server")


func _on_signaling_error(error: String) -> void:
	logger.log_error("Signaling error: " + error)


func _on_signaling_error_received(code: String, message: String) -> void:
	logger.log_error("Server error: %s - %s" % [code, message])

	# Map error codes to GDSync errors
	match code:
		"LOBBY_NOT_FOUND":
			GDSync.lobby_join_failed.emit.call_deferred(
				local_lobby_name, ENUMS.LOBBY_JOIN_ERROR.LOBBY_DOES_NOT_EXIST
			)
		"LOBBY_FULL":
			GDSync.lobby_join_failed.emit.call_deferred(
				local_lobby_name, ENUMS.LOBBY_JOIN_ERROR.LOBBY_IS_FULL
			)
		"LOBBY_CLOSED":
			GDSync.lobby_join_failed.emit.call_deferred(
				local_lobby_name, ENUMS.LOBBY_JOIN_ERROR.LOBBY_IS_CLOSED
			)


func _on_lobby_created(
	code: String, lobby_name: String, host_id: int, your_id: int
) -> void:
	var gdsync_id = GDSync.get_client_id()
	assert(your_id == gdsync_id,
		"LocalServerSignaling: Lobby created with your_id %d but expected GDSync's client_id %d" % [your_id, gdsync_id])
	logger.log_info(
		"Lobby created: %s '%s' (host=%d, me=%d)" % [code, lobby_name, host_id, your_id]
	)

	current_room_code = code
	is_host = true

	# IDs should already match GDSync's - just update local references
	my_current_client.client_id = your_id
	my_current_client.peer_id = your_id

	# Configure connection controller for host mode
	connection_controller.set_host(your_id)
	connection_controller.in_local_lobby = true
	connection_controller.status = ENUMS.CONNECTION_STATUS.LOCAL_CONNECTION
	connection_controller.set_process(false)

	# Add self to client tables
	var self_client = Client.new()
	self_client.peer_id = your_id
	self_client.client_id = your_id
	self_client.valid = true
	peer_client_table[your_id] = self_client
	lobby_client_table[your_id] = self_client

	# Add to found lobbies
	var lobby_dict: Dictionary = get_lobby_dictionary()
	lobby_dict["Code"] = current_room_code
	found_lobbies[local_lobby_name] = lobby_dict

	set_process(true)

	GDSync.lobby_created.emit.call_deferred(current_room_code)
	GDSync.client_joined.emit.call_deferred(my_current_client.client_id)


func _on_lobby_joined(
	code: String, lobby_name: String, host_id: int, your_id: int, players: Array
) -> void:
	var gdsync_id = GDSync.get_client_id()
	assert(your_id == gdsync_id,
		"LocalServerSignaling: Lobby joined with your_id %d but expected GDSync's client_id %d" % [your_id, gdsync_id])
	assert(host_id > 0, "LocalServerSignaling: Invalid host_id from signaling server: %d" % host_id)
	logger.log_info(
		"Lobby joined: %s '%s' (host=%d, me=%d, players=%d)"
		% [code, lobby_name, host_id, your_id, players.size()]
	)

	current_room_code = code
	is_host = false

	# IDs should already match GDSync's - just update local references
	my_current_client.client_id = your_id
	my_current_client.peer_id = your_id

	# Configure connection controller for client mode
	connection_controller.set_host(host_id)
	connection_controller.in_local_lobby = true
	connection_controller.status = ENUMS.CONNECTION_STATUS.LOCAL_CONNECTION
	connection_controller.set_process(false)

	# Add self to client tables
	var self_client = Client.new()
	self_client.peer_id = your_id
	self_client.client_id = your_id
	self_client.valid = true
	peer_client_table[your_id] = self_client
	lobby_client_table[your_id] = self_client

	# Add existing players from server and emit client_joined for each
	for player in players:
		# the ids will be sent in float form from the server, so we need to convert them to int
		var peer_id = int(player.get("id"))
		if peer_id == null:
			logger.log_error("Player data missing 'id': %s" % player)
		if peer_id > 0 and peer_id != your_id:
			var client = Client.new()
			client.peer_id = peer_id
			client.client_id = peer_id
			client.valid = true
			client.player_data = player.get("player", {})
			peer_client_table[peer_id] = client
			lobby_client_table[peer_id] = client
			# Notify GDSync about existing players
			GDSync.client_joined.emit.call_deferred(peer_id)

	# Rebuild lobby targets
	for cid in lobby_client_table:
		lobby_client_table[cid].construct_lobby_targets(lobby_client_table)

	set_process(true)

	# Emit lobby_joined first, then client_joined for self
	GDSync.lobby_joined.emit.call_deferred(code)
	# Also emit client_joined for ourselves so ConnectionManager tracks us
	GDSync.client_joined.emit.call_deferred(my_current_client.client_id)


func _on_lobby_left(code: String) -> void:
	logger.log_info("Left lobby: " + code)
	reset_multiplayer()


func _on_lobby_closed(code: String, reason: String) -> void:
	logger.log_info("Lobby closed: %s (reason: %s)" % [code, reason])

	# Notify GDSync that we were kicked
	if not is_host:
		GDSync.kicked.emit.call_deferred()

	reset_multiplayer()


func _on_lobby_list_received(lobbies: Array) -> void:
	logger.log_info("Received %d lobbies from server" % lobbies.size())

	# Convert to GDSync format
	var gdsync_lobbies: Array = []
	for lobby in lobbies:
		var gdsync_lobby = {
			"Name": lobby.get("name", ""),
			"Code": lobby.get("code", ""),
			"PlayerCount": lobby.get("players", 0),
			"PlayerLimit": lobby.get("player_limit", 0),
			"Public": lobby.get("public", true),
			"Open": true,
			"HasPassword": false,
		}
		gdsync_lobbies.append(gdsync_lobby)
		found_lobbies[gdsync_lobby["Name"]] = gdsync_lobby

	GDSync.lobbies_received.emit.call_deferred(gdsync_lobbies)


func _on_peer_joined_signaling(peer_id: int, player_data: Dictionary) -> void:
	logger.log_info("Peer joined via signaling: %d" % peer_id)

	# Create client entry
	var client = Client.new()
	client.peer_id = peer_id
	client.client_id = peer_id
	client.valid = true
	client.player_data = player_data
	peer_client_table[peer_id] = client
	lobby_client_table[peer_id] = client

	# Rebuild lobby targets
	for cid in lobby_client_table:
		lobby_client_table[cid].construct_lobby_targets(lobby_client_table)

	GDSync.client_joined.emit.call_deferred(peer_id)


func _on_peer_left_signaling(peer_id: int) -> void:
	logger.log_info("Peer left via signaling: %d" % peer_id)

	if lobby_client_table.has(peer_id):
		lobby_client_table.erase(peer_id)
	if peer_client_table.has(peer_id):
		peer_client_table.erase(peer_id)

	# Rebuild lobby targets
	for cid in lobby_client_table:
		lobby_client_table[cid].construct_lobby_targets(lobby_client_table)

	GDSync.client_left.emit.call_deferred(peer_id)


func _on_game_packet_received(from_peer: int, packet_base64: String) -> void:
	# Decode and process the packet
	var bytes = Marshalls.base64_to_raw(packet_base64)
	if bytes.is_empty():
		logger.log_warning("Received empty packet from peer %d" % from_peer)
		return

	if is_host:
		# Host receives packet from client - process and potentially broadcast
		_process_incoming_packet_as_host(from_peer, bytes)
	else:
		# Client receives packet from host - just unpack and process
		request_processor.unpack_packet(bytes)


# =============================================================================
# Process Loop (HTTP packet handling)
# =============================================================================


func _process(_delta: float) -> void:
	if not _is_initialized or current_room_code == "":
		return

	if is_host:
		_process_host()
	else:
		_process_client()


func _process_host() -> void:
	# IMPORTANT: Process the host's own SERVER requests first
	# When the HOST calls GDSync.set_gdsync_owner(), it queues to requestsSERV
	# but ConnectionController._process() skips LOCAL mode, so we must handle it here
	_process_host_server_requests()

	# Send queued requests to clients via HTTP
	# Like original LocalServer, send raw arrays (not using package_requests which wraps in Dictionary)
	for client_id in lobby_client_table.keys():
		if client_id == my_current_client.client_id:
			continue

		var client: Client = lobby_client_table[client_id]

		# Send reliable requests as raw array (like original LocalServer line 260)
		if not client.requests_RUDP.is_empty():
			var pkt = var_to_bytes(client.requests_RUDP)
			var packet_base64 = Marshalls.raw_to_base64(pkt)
			_signaling.broadcast_packet(packet_base64, client.client_id)
			client.requests_RUDP.clear()

		# Send unreliable requests as raw array (like original LocalServer line 265)
		if not client.requests_UDP.is_empty():
			var pkt = var_to_bytes(client.requests_UDP)
			var packet_base64 = Marshalls.raw_to_base64(pkt)
			_signaling.broadcast_packet(packet_base64, client.client_id)
			client.requests_UDP.clear()

		# Note: SERVER requests are typically not sent from host to client
		client.requests_SERVER.clear()


## Process the HOST's own SERVER requests (like set_gdsync_owner, lobby tags, etc.)
## These are queued by request_processor but never sent because ConnectionController
## skips LOCAL mode in _process(). We must handle them here.
func _process_host_server_requests() -> void:
	if not request_processor.has_packets(ENUMS.PACKET_CHANNEL.SERVER):
		return

	# Get the host's Client object
	var host_client: Client = lobby_client_table.get(my_current_client.client_id)
	if host_client == null:
		return

	# Package the SERVER requests - this returns bytes with Dictionary wrapper
	var pkt: PackedByteArray = request_processor.package_requests(ENUMS.PACKET_CHANNEL.SERVER)
	var message: Dictionary = bytes_to_var(pkt)

	# Process each SERVER request as if it came from a remote client
	if message.has(ENUMS.PACKET_VALUE.SERVER_REQUESTS):
		for request in message[ENUMS.PACKET_VALUE.SERVER_REQUESTS]:
			_process_server_request(host_client, request)


func _process_client() -> void:
	# Send queued requests to host via HTTP
	# IMPORTANT: Send ONLY to host, not broadcast to all peers
	# In GD-Sync architecture, clients talk to host only (star topology)
	var host_id: int = connection_controller.host

	var has_setup = request_processor.has_packets(ENUMS.PACKET_CHANNEL.SETUP)
	var has_server = request_processor.has_packets(ENUMS.PACKET_CHANNEL.SERVER)
	var has_reliable = request_processor.has_packets(ENUMS.PACKET_CHANNEL.RELIABLE)
	var has_unreliable = request_processor.has_packets(ENUMS.PACKET_CHANNEL.UNRELIABLE)

	if has_setup:
		var pkt = request_processor.package_requests(ENUMS.PACKET_CHANNEL.SETUP)
		var packet_base64 = Marshalls.raw_to_base64(pkt)
		_signaling.broadcast_packet(packet_base64, host_id)

	if has_server:
		var pkt = request_processor.package_requests(ENUMS.PACKET_CHANNEL.SERVER)
		var packet_base64 = Marshalls.raw_to_base64(pkt)
		_signaling.broadcast_packet(packet_base64, host_id)

	if has_reliable:
		var pkt = request_processor.package_requests(ENUMS.PACKET_CHANNEL.RELIABLE)
		var packet_base64 = Marshalls.raw_to_base64(pkt)
		_signaling.broadcast_packet(packet_base64, host_id)

	if has_unreliable:
		var pkt = request_processor.package_requests(ENUMS.PACKET_CHANNEL.UNRELIABLE)
		var packet_base64 = Marshalls.raw_to_base64(pkt)
		_signaling.broadcast_packet(packet_base64, host_id)


func _process_incoming_packet_as_host(from_peer: int, bytes: PackedByteArray) -> void:
	if not peer_client_table.has(from_peer):
		logger.log_warning("Unknown sender peer: " + str(from_peer))
		return

	var from: Client = peer_client_table[from_peer]
	var message: Dictionary = bytes_to_var(bytes)

	if message.has(ENUMS.PACKET_VALUE.SERVER_REQUESTS):
		for request in message[ENUMS.PACKET_VALUE.SERVER_REQUESTS]:
			_process_server_request(from, request)

	if message.has(ENUMS.PACKET_VALUE.CLIENT_REQUESTS):
		for request in message[ENUMS.PACKET_VALUE.CLIENT_REQUESTS]:
			_broadcast_request(request, from, true) # Always reliable over HTTP


# =============================================================================
# Server Request Processing (Host only)
# =============================================================================


func _process_server_request(from: Client, request: Array) -> void:
	var request_type: int = request[ENUMS.DATA.REQUEST_TYPE]

	match request_type:
		ENUMS.REQUEST_TYPE.SET_CLIENT_ID:
			from.client_id = request[ENUMS.DATA.NAME]
		ENUMS.REQUEST_TYPE.JOIN_LOBBY:
			_join_lobby_request(from, request)
		ENUMS.REQUEST_TYPE.LEAVE_LOBBY:
			_leave_lobby_request(from)
		ENUMS.REQUEST_TYPE.OPEN_LOBBY:
			local_lobby_open = true
		ENUMS.REQUEST_TYPE.CLOSE_LOBBY:
			local_lobby_open = false
		ENUMS.REQUEST_TYPE.SET_GDSYNC_OWNER:
			_set_owner_request(from, request)
		ENUMS.REQUEST_TYPE.SET_LOBBY_TAG:
			_set_lobby_tag_request(from, request)
		ENUMS.REQUEST_TYPE.ERASE_LOBBY_TAG:
			_erase_lobby_tag_request(from, request)
		ENUMS.REQUEST_TYPE.SET_LOBBY_DATA:
			_set_lobby_data_request(from, request)
		ENUMS.REQUEST_TYPE.ERASE_LOBBY_DATA:
			_erase_lobby_data_request(from, request)
		ENUMS.REQUEST_TYPE.SET_PLAYER_USERNAME:
			_set_player_username_request(from, request)
		ENUMS.REQUEST_TYPE.SET_PLAYER_DATA:
			_set_player_data_request(from, request)
		ENUMS.REQUEST_TYPE.ERASE_PLAYER_DATA:
			_erase_player_data_request(from, request)


func _broadcast_request(request: Array, from: Client, reliable: bool) -> void:
	if not from.valid:
		return

	var peers: Array = _get_target_peers(request, from)
	for client in peers:
		if connection_controller.USE_SENDER_ID:
			_set_sender_id(from, client, reliable)
		_put_request(request, client, reliable)


func _get_target_peers(request: Array, from: Client) -> Array:
	var targets: Array = []
	if from.valid:
		var target_client: int = int(request[int(ENUMS.DATA.TARGET_CLIENT)])
		if target_client >= 0:
			if lobby_client_table.has(target_client):
				targets.append(lobby_client_table[target_client])
		else:
			return from.lobby_targets
	return targets


func _set_sender_id(from: Client, client: Client, reliable: bool) -> void:
	if not connection_controller.USE_SENDER_ID:
		return
	_put_request(
		[
			int(ENUMS.REQUEST_TYPE.MESSAGE),
			int(ENUMS.MESSAGE_TYPE.SET_SENDER_ID),
			from.client_id
		],
		client,
		reliable
	)


func _put_request(request: Array, client: Client, reliable: bool) -> void:
	if reliable:
		client.requests_RUDP.append(request)
	else:
		client.requests_UDP.append(request)


func _send_message(
	message: int, client: Client, value=null, value2=null, value3=null
) -> void:
	if client == null:
		return
	if value3 != null:
		_put_request(
			[int(ENUMS.REQUEST_TYPE.MESSAGE), message, value, value2, value3],
			client,
			true
		)
	elif value2 != null:
		_put_request(
			[int(ENUMS.REQUEST_TYPE.MESSAGE), message, value, value2],
			client,
			true
		)
	elif value != null:
		_put_request(
			[int(ENUMS.REQUEST_TYPE.MESSAGE), message, value], client, true
		)
	else:
		_put_request([int(ENUMS.REQUEST_TYPE.MESSAGE), message], client, true)


func _join_lobby_request(from: Client, request: Array) -> void:
	if local_lobby_name == "" or current_room_code == "":
		return

	if not local_lobby_open:
		_send_message(
			ENUMS.MESSAGE_TYPE.LOBBY_JOIN_FAILED,
			from,
			current_room_code,
			ENUMS.LOBBY_JOIN_ERROR.LOBBY_IS_CLOSED
		)
		return

	if (
		local_lobby_player_limit > 0
		and lobby_client_table.size() >= local_lobby_player_limit
	):
		_send_message(
			ENUMS.MESSAGE_TYPE.LOBBY_JOIN_FAILED,
			from,
			current_room_code,
			ENUMS.LOBBY_JOIN_ERROR.LOBBY_IS_FULL
		)
		return

	var password: String = request[ENUMS.LOBBY_DATA.PASSWORD]
	if local_lobby_password != "" and password != local_lobby_password:
		_send_message(
			ENUMS.MESSAGE_TYPE.LOBBY_JOIN_FAILED,
			from,
			current_room_code,
			ENUMS.LOBBY_JOIN_ERROR.INCORRECT_PASSWORD
		)
		return

	if connection_controller.UNIQUE_USERNAMES:
		for client in lobby_client_table.values():
			if client.username == from.username:
				_send_message(
					ENUMS.MESSAGE_TYPE.LOBBY_JOIN_FAILED,
					from,
					current_room_code,
					ENUMS.LOBBY_JOIN_ERROR.DUPLICATE_USERNAME
				)
				return

	from.valid = true
	lobby_client_table[from.client_id] = from

	_send_message(ENUMS.MESSAGE_TYPE.LOBBY_JOINED, from, current_room_code)
	_send_message(ENUMS.MESSAGE_TYPE.HOST_CHANGED, from, GDSync.get_client_id())
	_send_message(
		ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED, from, get_lobby_dictionary(true)
	)

	for client_id in lobby_client_table:
		var client: Client = lobby_client_table[client_id]
		client.construct_lobby_targets(lobby_client_table)

		if client != from:
			_send_message(
				ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED,
				client,
				from.collect_player_data()
			)
			_send_message(
				ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED,
				from,
				client.collect_player_data()
			)
			_send_message(
				ENUMS.MESSAGE_TYPE.CLIENT_JOINED, client, from.client_id
			)

		_send_message(ENUMS.MESSAGE_TYPE.CLIENT_JOINED, from, client.client_id)

	for node_path in local_owner_cache:
		_send_message(
			ENUMS.MESSAGE_TYPE.SET_GDSYNC_OWNER,
			from,
			node_path,
			local_owner_cache[node_path]
		)


func _leave_lobby_request(from: Client) -> void:
	if lobby_client_table.has(from.client_id):
		lobby_client_table.erase(from.client_id)

		if from.client_id != GDSync.get_client_id():
			for client_id in lobby_client_table:
				var other_client: Client = lobby_client_table[client_id]
				other_client.construct_lobby_targets(lobby_client_table)

				if other_client != from:
					_send_message(
						ENUMS.MESSAGE_TYPE.CLIENT_LEFT,
						other_client,
						from.client_id
					)
		else:
			for client_id in lobby_client_table:
				var other_client: Client = lobby_client_table[client_id]
				if other_client != from:
					_send_message(ENUMS.MESSAGE_TYPE.KICKED, other_client)
			clear_lobby_data()

	if peer_client_table.has(from.peer_id):
		peer_client_table.erase(from.peer_id)


func _set_owner_request(from: Client, request: Array) -> void:
	if not from.valid:
		return
	var node_path = request[ENUMS.DATA.NAME]
	var owner_id = request[ENUMS.DATA.VALUE]
	if owner_id == null or owner_id == -1:
		if local_owner_cache.has(node_path):
			local_owner_cache.erase(node_path)
	else:
		local_owner_cache[node_path] = owner_id

	for client_id in lobby_client_table:
		_send_message(
			ENUMS.MESSAGE_TYPE.SET_GDSYNC_OWNER,
			lobby_client_table[client_id],
			node_path,
			owner_id
		)


func _set_lobby_tag_request(_from: Client, request: Array) -> void:
	var key = request[ENUMS.LOBBY_DATA.NAME]
	var value = request[ENUMS.LOBBY_DATA.VALUE]
	local_lobby_tags[key] = value

	for client in lobby_client_table.values():
		_send_message(
			ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED,
			client,
			get_lobby_dictionary(true)
		)
		_send_message(ENUMS.MESSAGE_TYPE.LOBBY_TAGS_CHANGED, client, key)


func _erase_lobby_tag_request(_from: Client, request: Array) -> void:
	var key = request[ENUMS.LOBBY_DATA.NAME]
	if local_lobby_tags.has(key):
		local_lobby_tags.erase(key)
		for client in lobby_client_table.values():
			_send_message(
				ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED,
				client,
				get_lobby_dictionary(true)
			)
			_send_message(ENUMS.MESSAGE_TYPE.LOBBY_TAGS_CHANGED, client, key)


func _set_lobby_data_request(_from: Client, request: Array) -> void:
	var key = request[ENUMS.LOBBY_DATA.NAME]
	var value = request[ENUMS.LOBBY_DATA.VALUE]
	local_lobby_data[key] = value

	for client in lobby_client_table.values():
		_send_message(
			ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED,
			client,
			get_lobby_dictionary(true)
		)
		_send_message(ENUMS.MESSAGE_TYPE.LOBBY_DATA_CHANGED, client, key)


func _erase_lobby_data_request(_from: Client, request: Array) -> void:
	var key = request[ENUMS.LOBBY_DATA.NAME]
	if local_lobby_data.has(key):
		local_lobby_data.erase(key)
		for client in lobby_client_table.values():
			_send_message(
				ENUMS.MESSAGE_TYPE.LOBBY_DATA_RECEIVED,
				client,
				get_lobby_dictionary(true)
			)
			_send_message(ENUMS.MESSAGE_TYPE.LOBBY_DATA_CHANGED, client, key)


func _set_player_username_request(from: Client, request: Array) -> void:
	from.username = request[ENUMS.DATA.NAME]
	for client in from.lobby_targets:
		_send_message(
			ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED,
			client,
			from.collect_player_data()
		)
		_send_message(
			ENUMS.MESSAGE_TYPE.PLAYER_DATA_CHANGED,
			client,
			from.client_id,
			"Username"
		)


func _set_player_data_request(from: Client, request: Array) -> void:
	var key = request[ENUMS.DATA.NAME]
	from.player_data[key] = request[ENUMS.DATA.VALUE]
	for client in from.lobby_targets:
		_send_message(
			ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED,
			client,
			from.collect_player_data()
		)
		_send_message(
			ENUMS.MESSAGE_TYPE.PLAYER_DATA_CHANGED, client, from.client_id, key
		)


func _erase_player_data_request(from: Client, request: Array) -> void:
	var key = request[ENUMS.DATA.NAME]
	if from.player_data.has(key):
		from.player_data.erase(key)
		for client in from.lobby_targets:
			_send_message(
				ENUMS.MESSAGE_TYPE.PLAYER_DATA_RECEIVED,
				from,
				from.collect_player_data()
			)
			_send_message(
				ENUMS.MESSAGE_TYPE.PLAYER_DATA_CHANGED,
				from,
				from.client_id,
				key
			)


# =============================================================================
# Utility Methods
# =============================================================================


func set_signaling_server(url: String) -> void:
	signaling_server_url = url


func perform_local_scan() -> void:
	pass # Not needed - signaling server handles discovery


func get_lobby_dictionary(with_data: bool = false) -> Dictionary:
	var dict: Dictionary = {
		"Name": local_lobby_name,
		"PlayerCount": lobby_client_table.size(),
		"PlayerLimit": local_lobby_player_limit,
		"Public": local_lobby_public,
		"Open": local_lobby_open,
		"Tags": local_lobby_tags,
		"HasPassword": local_lobby_password != "",
		"Host": GDSync.player_get_data(GDSync.get_client_id(), "Username", ""),
		"Code": current_room_code if current_room_code else ""
	}

	if with_data:
		dict["Data"] = local_lobby_data

	return dict


func get_room_code() -> String:
	return current_room_code
